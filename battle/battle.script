local game_state = require "common/game_state"
local encounters = require "common/encounters"
local moves = require "common/moves"
local status_effects = require "common/status_effects"
local types = require "common/poke_types"
local player_mon1 = {}
local player_mon2 = nil
local player_mon3 = nil
local player_mon4 = nil
local enemy_mon1 = nil
local enemy_mon2 = nil
local enemy_mon3 = nil
local enemy_mon4 = nil
local enemy_boss = nil
local selected_move = {}
local selected_move_slot = 1
local spawned_target_icons = {}
local spawned_turn_markers = {}
local current_turn_mon = nil
local combatants = {}
local waiting_for_target = false

function init(self)
	msg.post(".", "acquire_input_focus")
	load_data_for_battle()
	msg.post(".", "find_next_turn")
end

function final(self)
end

function update(self, dt)
end

function on_message(self, message_id, message, sender)
	if message_id == hash("move_selected") then
		if(current_turn_mon["move"..message.slot.."cd"] == 0) then
			selected_move_slot = message.slot
			selected_move = moves[current_turn_mon.known_moves[message.move].id]
			display_targetting_icons()
			waiting_for_target = true
		end
	end
	if message_id == hash("target_selected") then
		if(waiting_for_target and target_is_valid(message.target)) then
			--valid target, execute the move and then end the turn.
			waiting_for_target = false
			clear_gos(spawned_target_icons)
			msg.post("gui", "hide_mon_display")
			current_turn_mon["move"..selected_move_slot.."cd"] = selected_move.cooldown
			start_handling_move(message.target)
			timer.delay(1, false, function() msg.post(".", "end_turn") end)
		end
	end
	if message_id == hash("find_next_turn") then
		if current_turn_mon ~= nil then
			msg.post("gui", "update_turn", {target=current_turn_mon.reference, current=current_turn_mon.turn, max=1000})
		end
		if player_mon1.turn > 1000 and not player_mon1.fainted then
			player_mon1.turn = player_mon1.turn - 1000
			current_turn_mon = player_mon1
			start_player_turn(player_mon1)
		elseif player_mon2 ~= nil and player_mon2.turn > 1000 and not player_mon2.fainted then
			player_mon2.turn = player_mon2.turn - 1000
			current_turn_mon = player_mon2
			start_player_turn(player_mon2)
		elseif player_mon3 ~= nil and player_mon3.turn > 1000 and not player_mon3.fainted then
			player_mon3.turn = player_mon3.turn - 1000
			current_turn_mon = player_mon3
			start_player_turn(player_mon3)
		elseif player_mon4 ~= nil and player_mon4.turn > 1000 and not player_mon4.fainted then
			player_mon4.turn = player_mon4.turn - 1000
			current_turn_mon = player_mon4
			start_player_turn(player_mon4)
		elseif enemy_boss ~= nil and enemy_boss.turn > 1000 and not enemy_boss.fainted then
			enemy_boss.turn = enemy_boss.turn - 1000
			current_turn_mon = enemy_boss
			start_enemy_turn(enemy_boss)
		elseif enemy_mon1 ~= nil and enemy_mon1.turn > 1000 and not enemy_mon1.fainted then
			enemy_mon1.turn = enemy_mon1.turn - 1000
			current_turn_mon = enemy_mon1
			start_enemy_turn(enemy_mon1)
		elseif enemy_mon2 ~= nil and enemy_mon2.turn > 1000 and not enemy_mon2.fainted then
			enemy_mon2.turn = enemy_mon2.turn - 1000
			current_turn_mon = enemy_mon2
			start_enemy_turn(enemy_mon2)
		elseif enemy_mon3 ~= nil and enemy_mon3.turn > 1000 and not enemy_mon3.fainted then
			enemy_mon3.turn = enemy_mon3.turn - 1000
			current_turn_mon = enemy_mon3
			start_enemy_turn(enemy_mon3)
		elseif enemy_mon4 ~= nil and enemy_mon4.turn > 1000 and not enemy_mon4.fainted then
			enemy_mon4.turn = enemy_mon4.turn - 1000
			current_turn_mon = enemy_mon4
			start_enemy_turn(enemy_mon4)
		else
			timer.delay(.1, false, increment_turns)
		end
	end
	if message_id == hash("end_turn") then
		reduce_status_effect_durations(current_turn_mon, 1, true)
		clear_gos(spawned_turn_markers)
		msg.post(".", "find_next_turn")
	end
end

-- Learn more: https://defold.com/manuals/input/
function on_input(self, action_id, action)
end

function on_reload(self)
	-- Add reload-handling code here
	-- Learn more: https://defold.com/manuals/hot-reload/
end

function start_handling_move(target)
	local battle_text = ""
	if string.match(current_turn_mon.reference, "^enemy") then
		battle_text = "Enemy "
	end
	msg.post("gui", "set_battle_text", {text = battle_text..current_turn_mon.name.." used "..selected_move.name.."!"})
	local delay_time = 0.0

	level = current_turn_mon.known_moves[current_turn_mon["move"..selected_move_slot]].level
	
	for index, effect in ipairs(selected_move.effects) do

		if (effect.target < 3) then --self, enemy, ally, only affect target selected.
			timer.delay(delay_time, false, function() handle_move_effects(level, effect, target, current_turn_mon) end)
		elseif (effect.target == 3) then -- all enemies
			if string.match(current_turn_mon.reference, "^enemy") then -- an enemy mon using the move
				for i=1,4 do
					if(combatants["player_mon"..i] ~= nil and not combatants["player_mon"..i].fainted) then
						timer.delay(delay_time, false, function() handle_move_effects(level, effect, "player_mon"..i, current_turn_mon) end)
					end
				end
			else -- player mon using the move
				for i=1,4 do
					if(combatants["enemy_mon"..i] ~= nil and not combatants["enemy_mon"..i].fainted) then
						timer.delay(delay_time, false, function() handle_move_effects(level, effect, "enemy_mon"..i, current_turn_mon) end)
					end
				end
				if game_state.battle_type == 3 then
					timer.delay(delay_time, false, function() handle_move_effects(level, effect, "enemy_boss", current_turn_mon) end)
				end
			end
		elseif (effect.target == 4) then -- all allies
			if string.match(current_turn_mon.reference, "^enemy") then -- an enemy mon using the move
				for i=1,4 do
					if(combatants["enemy_mon"..i] ~= nil and not combatants["enemy_mon"..i].fainted) then
						timer.delay(delay_time, false, function() handle_move_effects(level, effect, "enemy_mon"..i, current_turn_mon) end)
					end
				end
				if game_state.battle_type == 3 then
					timer.delay(delay_time, false, function() handle_move_effects(level, effect, "enemy_boss", current_turn_mon) end)
				end
			else -- player mon using the move
				for i=1,4 do
					if(combatants["player_mon"..i] ~= nil and not combatants["player_mon"..i].fainted) then
						timer.delay(delay_time, false, function() handle_move_effects(level, effect, "player_mon"..i, current_turn_mon) end)
					end
				end
			end
		end
		delay_time = delay_time + 0.3
	end
end

function handle_move_effects(level, effect, target, move_user)
	effectiveness = types.type_effectiveness(selected_move.type, combatants[target].type1, combatants[target].type2)
	if not combatants[target].fainted then
		
		if effect.id == 1 then --deal damage
			local defender = combatants[target]
			stat = move_user[effect.param2]
			if mon_has_status_effect(move_user, 2) then
				stat = stat / 2
			elseif mon_has_status_effect(move_user, 3) then
				stat = stat * 1.5
			end
			local power = effect.param1(level) * stat / 100
			local defense = defender.defense
			if effect.ignore_def ~= nil then
				defense = defense * (100 - effect.ignore_def) / 100
			end
			local damage = math.floor(calc_damage(power, defense) * effectiveness / 100)
			if mon_has_status_effect(defender, 4) then
				damage = damage * 2
			end
			if mon_has_status_effect(defender, 5) then
				damage = math.ceil(damage / 2)
			end
			crit_rng = math.random(1,100)
			text_color = "white"
			if effect.extra_crit ~= nil then
				crit_rng = crit_rng - effect.extra_crit
			end
			if crit_rng <= move_user.crit_chance then
				damage = math.floor(damage * (1 + (move_user.crit_damage / 100)))
				text_color = "yellow"
			end
			display_damage_text(go.get_position(defender.reference),""..damage, text_color)
			damage_defender(defender, damage)
		elseif effect.id == 2 then --reduce attack
			local defender = combatants[target]
			local duration = effect.param2
			if(should_apply_debuff(move_user, effectiveness, defender.resist, effect.param1(level))) then
				apply_status_effect(defender, 2, duration)
			else
				display_damage_text(go.get_position(defender.reference), "resist", "red")
			end
		elseif effect.id == 3 then --increase attack
			local defender = combatants[target]
			local duration = effect.param2
			apply_status_effect(defender, 3, duration)
		elseif effect.id == 4 then --reduce defense
			local defender = combatants[target]
			local duration = effect.param2
			if(should_apply_debuff(move_user, effectiveness, defender.resist, effect.param1(level))) then
				apply_status_effect(defender, 4, duration)
			else
				display_damage_text(go.get_position(defender.reference), "resist", "red")
			end
		elseif effect.id == 5 then --increase defense
			local defender = combatants[target]
			local duration = effect.param2
			apply_status_effect(defender, 5, duration)
		elseif effect.id == 6 then --damage based on max hp
			local defender = combatants[target]
			local power = effect.param1(level) * defender.hp / 100
			local defense = defender.defense
			local damage = math.floor(calc_damage(power, defense) * effectiveness / 100)
			if mon_has_status_effect(defender, 4) then
				damage = damage * 2
			end
			if mon_has_status_effect(defender, 5) then
				damage = math.ceil(damage / 2)
			end
			crit_rng = math.random(1,100)
			text_color = "white"
			if crit_rng <= move_user.crit_chance then
				damage = math.floor(damage * (1 + (move_user.crit_damage / 100)))
				text_color = "yellow"
			end
			display_damage_text(go.get_position(defender.reference),""..damage, text_color)
			damage_defender(defender, damage)
		elseif effect.id == 7 then --increase speed
			local defender = combatants[target]
			local duration = effect.param2
			apply_status_effect(defender, 7, duration)
		elseif effect.id == 8 then --increase turn
			local defender = combatants[target]
			local turn_amount = effect.param2 * 10
			modify_turn_meter(defender, effect.id, turn_amount)
		elseif effect.id == 9 then --reduce accuracy
			local defender = combatants[target]
			local duration = effect.param2
			if(should_apply_debuff(move_user, effectiveness, defender.resist, effect.param1(level))) then
				apply_status_effect(defender, 9, duration)
			else
				display_damage_text(go.get_position(defender.reference), "resist", "red")
			end
		elseif effect.id == 10 then --reduce speed
			local defender = combatants[target]
			local duration = effect.param2
			if(should_apply_debuff(move_user, effectiveness, defender.resist, effect.param1(level))) then
				apply_status_effect(defender, 10, duration)
			else
				display_damage_text(go.get_position(defender.reference), "resist", "red")
			end
		elseif effect.id == 11 then --sleep
			local defender = combatants[target]
			local duration = effect.param2
			if(should_apply_debuff(move_user, effectiveness, defender.resist, effect.param1(level))) then
				apply_status_effect(defender, 11, duration)
			else
				display_damage_text(go.get_position(defender.reference), "resist", "red")
			end
		end
		
	end
end

function should_apply_debuff(move_user, effectiveness, resist, debuff_chance)
	accuracy = move_user.accuracy + effectiveness - 100
	if mon_has_status_effect(move_user, 9) then
		accuracy = accuracy / 2
	end
	x = accuracy - resist
	if x < 0 then
		x = 0
	end
	y = resist - accuracy
	if y < 0 then
		y = 0
	end
	chance_to_apply = math.ceil(100 * (1 - 0.25 * (math.pow(0.99, x))) * (math.pow(0.99, y)))
	accuracy_calc_rng = math.random(1,100)
	move_chance_rng = math.random(1,100)

	should_apply = false
	if(accuracy_calc_rng <= chance_to_apply and move_chance_rng <= debuff_chance)then
		should_apply = true
	end
	return should_apply
	--return true --DEV: leaving this to make testing debuffs easier
end

function apply_status_effect(defender, effect_id, duration)
	effect = {}
	effect.duration = duration
	effect.category = status_effects[effect_id].category
	effect.type = effect_id
	--if someone is applying a buff to themself then mark it to not reduce its duration at the end of this turn.
	if(status_effects[effect_id].category == 1 and current_turn_mon.reference == defender.reference) then
		effect.ignore_duration_reduction = true
	else
		effect.ignore_duration_reduction = false
	end
	p = go.get_position(defender.reference)
	p.y = p.y + 125
	p.x = p.x - 10
	effect_go = factory.create("#status_effect_factory",p, nil, {duration = duration, image = hash(status_effects[effect_id].sprite_name)})
	effect.go_id = effect_go
	table.insert(defender.status_effects, effect)
	display_damage_text(go.get_position(defender.reference), status_effects[effect_id].damage_text, "white")
	position_status_effects(defender)
end

function modify_turn_meter(defender, effect_id, amount)
	defender.turn = defender.turn + amount
	text_color = "white"
	damage_text = "turn boost"
	display_damage_text(go.get_position(defender.reference), damage_text, text_color)
	msg.post("gui", "update_turn", {target=defender.reference, current=defender.turn, max=1000})
end

function display_damage_text(position, text, text_color)
	damage_text = factory.create("#effect_text_factory", position, nil)
	msg.post(damage_text, "set_values", {label_text = text, label_color = text_color})
end

function position_status_effects(mon)
	p = go.get_position(mon.reference)
	p.y = p.y + 125
	p.x = p.x - 10
	for i, eff in ipairs(mon.status_effects) do
		go.set_position(p, eff.go_id)
		p.x = p.x + 32
	end
end

function reduce_status_effect_durations(mon, dur, end_of_turn)
	status_effects_to_remove = {}
	for i, eff in ipairs(mon.status_effects) do
		if(end_of_turn and eff.ignore_duration_reduction) then
			--prevent a pokemon who just buffed themself from immediately losing a turn of the buff at the end of their turn.
			eff.ignore_duration_reduction = false
		else
			eff.duration = eff.duration - dur
			msg.post(eff.go_id, "update_duration", {duration = eff.duration})
			if eff.duration < 1 then
				table.insert(status_effects_to_remove, i)
				go.delete(eff.go_id)
			end
		end
	end
	for i, setr in ipairs(status_effects_to_remove) do
		table.remove(mon.status_effects, i)
	end
	position_status_effects(mon)
end

function mon_has_status_effect(mon, effect_id)
	has_status_effect = false
	for i, eff in ipairs(mon.status_effects) do
		if eff.type == effect_id then
			has_status_effect = true
		end
	end
	return has_status_effect
end

function mon_can_act(mon)
	can_act = true
	for i, eff in ipairs(mon.status_effects) do
		if eff.category == 4 then --loss of control
			can_act = false
		end
	end
	return can_act
end

function damage_defender(defender, damage)
	defender.currenthp = defender.currenthp - damage

	--taking damage wakes up a sleeping pokemon
	for i, eff in ipairs(defender.status_effects) do
		if eff.type == 11 then
			go.delete(eff.go_id)
			defender.status_effects[i] = nil
		end
	end
	
	if defender.currenthp <= 0 then
		defender.currenthp = 0
		defender.fainted = true
		defender.turn = 0
		msg.post("gui", "disable_mon", {mon = defender.reference})
		msg.post(defender.reference.."#sprite", "disable")
		for i, eff in ipairs(defender.status_effects) do
			go.delete(eff.go_id)
			defender.status_effects[i] = nil
		end
	else
		msg.post("gui", "update_hp", {target=defender.reference, current=defender.currenthp, max=defender.hp})
	end

	if enemies_are_fainted() then
		timer.delay(0.5, false, function() msg.post("main:/loader#main", "end_battle", {victory = true}) end)
	elseif player_mons_are_fainted() then
		timer.delay(0.5, false, function() msg.post("main:/loader#main", "end_battle", {victory = false}) end)
	end
end

function enemies_are_fainted()
	fainted = false
	if game_state.battle_type == 3 then --boss fight
		fainted = enemy_boss.fainted
	else
		fainted = (enemy_mon1 == nil or enemy_mon1.fainted) 
		and (enemy_mon2 == nil or enemy_mon2.fainted) 
		and (enemy_mon3 == nil or enemy_mon3.fainted) 
		and (enemy_mon4 == nil or enemy_mon4.fainted)
	end
	return fainted
end

function player_mons_are_fainted()
	fainted = player_mon1.fainted and 
		(player_mon2 == nil or player_mon2.fainted) and 
		(player_mon3 == nil or player_mon3.fainted) and 
		(player_mon4 == nil or player_mon4.fainted)

	return fainted
end

function calc_damage(power, defense)
	modded_def = defense * 400 / (400 + defense)
	damage_modifier = 100 / (100 + modded_def)
	return math.ceil(power * damage_modifier)
end

function reduce_all_cooldowns(mon, amount)
	for i=1,4 do
		mon["move"..i.."cd"] = mon["move"..i.."cd"] - amount
		if mon["move"..i.."cd"] < 0 then
			mon["move"..i.."cd"] = 0
		end
	end
end

function load_data_for_battle()
	load_player_mon_data()
	load_enemy_data()
end

function start_player_turn(turn_mon)
	reduce_all_cooldowns(turn_mon, 1)
	local p = go.get_position(turn_mon.reference)
	p.y = p.y - 60
	p.z = p.z - 1
	local turn_marker = factory.create("#turn_marker_factory",p, nil, nil, 2.0)
	table.insert(spawned_turn_markers, turn_marker)
	
	if mon_can_act(turn_mon) then
		msg.post("gui", "display_mon", {mon = turn_mon})
	else
		timer.delay(.5, false, function() msg.post(".", "end_turn") end)
	end
end

function start_enemy_turn(turn_mon)
	reduce_all_cooldowns(turn_mon, 1)
	local p = go.get_position(turn_mon.reference)
	p.z = p.z - 1
	scale = (game_state.battle_type == 3 and 4 or 2)
	yshift = (game_state.battle_type == 3 and 128 or 32)
	p.y = p.y - yshift
	local turn_marker = factory.create("#turn_marker_factory",p, nil, nil, scale)
	table.insert(spawned_turn_markers, turn_marker)
	
	if mon_can_act(turn_mon) then
		timer.delay(1, false, choose_enemy_move)
		timer.delay(2, false, function() msg.post(".", "end_turn") end)
	else
		timer.delay(.5, false, function() msg.post(".", "end_turn") end)
	end
end

function choose_enemy_move()
	is_move_chosen = false
	local target = ""
	while is_move_chosen == false do
		random_move = math.random(1,4) -- choose a move at random
		-- see if the move is off cooldown
		if(current_turn_mon["move"..random_move] ~= nil and current_turn_mon["move"..random_move.."cd"] == 0) then
			selected_move = moves[current_turn_mon.known_moves[current_turn_mon["move"..random_move]].id]
			selected_move_slot = random_move
			is_move_chosen = true
			current_turn_mon["move"..random_move.."cd"] = current_turn_mon["move"..random_move.."cd"] + selected_move.cooldown
		end
	end

	is_target_chosen = false
	local target_chosen
	if selected_move.targetting == 0 then
		target = current_turn_mon.reference
	elseif selected_move.targetting == 1 then
		while is_target_chosen == false do
			target_chosen = math.random(1,4)
			if(combatants["player_mon"..target_chosen] ~= nil) then
				target = combatants["player_mon"..target_chosen].reference
				is_target_chosen = true
			end
		end
	elseif selected_move.targetting == 2 then
		local target_chosen = math.random(1,4)
		target = combatants["enemy_mon"..target_chosen].reference
	end
	
	start_handling_move(target)
end

function increment_mon_turn(mon)
	if mon ~= nil and not mon.fainted then
		local speed = mon.speed
		if mon_has_status_effect(mon, 7) then
			speed = speed * 1.3
		end
		if mon_has_status_effect(mon, 10) then
			speed = speed / 1.3
		end
		mon.turn = mon.turn + speed
		msg.post("gui", "update_turn", {target=mon.reference, current=mon.turn, max=1000})
	end
end

function increment_turns()
	local mon = {}
	for i=1,4 do
		mon = combatants["player_mon"..i]
		increment_mon_turn(mon)
		mon = combatants["enemy_mon"..i]
		increment_mon_turn(mon)
	end
	mon = combatants["enemy_boss"]
	increment_mon_turn(mon)
	
	msg.post(".", "find_next_turn")
end


function load_player_mon_data()
	player_mon1 = game_state.pokemon[game_state.player_mon1]
	player_mon1.currenthp = player_mon1.hp
	player_mon1.turn = 0
	player_mon1.reference = "player_mon1"
	player_mon1.move1cd = 0
	player_mon1.move2cd = 0
	player_mon1.move3cd = 0
	player_mon1.move4cd = 0
	player_mon1.status_effects = {}
	player_mon1.fainted = false
	msg.post("player_mon1#sprite", "play_animation", { id = hash(player_mon1.name.."_back_original") })
	combatants["player_mon1"] = player_mon1

	if game_state.player_mon2 ~= nil then
		player_mon2 = game_state.pokemon[game_state.player_mon2]
		player_mon2.currenthp = player_mon2.hp
		player_mon2.turn = 0
		player_mon2.reference = "player_mon2"
		player_mon2.move1cd = 0
		player_mon2.move2cd = 0
		player_mon2.move3cd = 0
		player_mon2.move4cd = 0
		player_mon2.status_effects = {}
		player_mon2.fainted = false
		msg.post("player_mon2#sprite", "play_animation", { id = hash(player_mon2.name.."_back_original") })
		combatants["player_mon2"] = player_mon2
	else
		msg.post("player_mon2", "disable")
		msg.post("gui", "disable_mon", {mon = "player_mon2"})
	end

	if game_state.player_mon3 ~= nil then
		player_mon3 = game_state.pokemon[game_state.player_mon3]
		player_mon3.currenthp = player_mon3.hp
		player_mon3.turn = 0
		player_mon3.reference = "player_mon3"
		player_mon3.move1cd = 0
		player_mon3.move2cd = 0
		player_mon3.move3cd = 0
		player_mon3.move4cd = 0
		player_mon3.status_effects = {}
		player_mon3.fainted = false
		msg.post("player_mon3#sprite", "play_animation", { id = hash(player_mon3.name.."_back_original") })
		combatants["player_mon3"] = player_mon3
	else
		msg.post("player_mon3", "disable")
		msg.post("gui", "disable_mon", {mon = "player_mon3"})
	end

	if game_state.player_mon4 ~= nil then
		player_mon4 = game_state.pokemon[game_state.player_mon4]
		player_mon4.currenthp = player_mon4.hp
		player_mon4.turn = 0
		player_mon4.reference = "player_mon4"
		player_mon4.move1cd = 0
		player_mon4.move2cd = 0
		player_mon4.move3cd = 0
		player_mon4.move4cd = 0
		player_mon4.status_effects = {}
		player_mon4.fainted = false
		msg.post("player_mon4#sprite", "play_animation", { id = hash(player_mon4.name.."_back_original") })
		combatants["player_mon4"] = player_mon4
	else
		msg.post("player_mon4", "disable")
		msg.post("gui", "disable_mon", {mon = "player_mon4"})
	end
end

function load_enemy_data()
	if game_state.enemy_mon1 ~= nil then
		enemy_mon1 = game_state.enemy_mon1
		enemy_mon1.currenthp = enemy_mon1.hp
		enemy_mon1.turn = 0
		enemy_mon1.reference = "enemy_mon1"
		enemy_mon1.move1cd = 0
		enemy_mon1.move2cd = 0
		enemy_mon1.move3cd = 0
		enemy_mon1.move4cd = 0
		enemy_mon1.status_effects = {}
		enemy_mon1.fainted = false
		msg.post("enemy_mon1#sprite", "play_animation", { id = hash(enemy_mon1.name.."_front_original") })
		combatants["enemy_mon1"] = enemy_mon1
	else
		msg.post("enemy_mon1", "disable")
		msg.post("gui", "disable_mon", {mon = "enemy_mon1"})
	end

	if game_state.enemy_mon2 ~= nil then
		enemy_mon2 = game_state.enemy_mon2
		enemy_mon2.currenthp = enemy_mon2.hp
		enemy_mon2.turn = 0
		enemy_mon2.reference = "enemy_mon2"
		enemy_mon2.move1cd = 0
		enemy_mon2.move2cd = 0
		enemy_mon2.move3cd = 0
		enemy_mon2.move4cd = 0
		enemy_mon2.status_effects = {}
		enemy_mon2.fainted = false
		msg.post("enemy_mon2#sprite", "play_animation", { id = hash(enemy_mon2.name.."_front_original") })
		combatants["enemy_mon2"] = enemy_mon2
	else
		msg.post("enemy_mon2", "disable")
		msg.post("gui", "disable_mon", {mon = "enemy_mon2"})
	end

	if game_state.enemy_mon3 ~= nil then
		enemy_mon3 = game_state.enemy_mon3
		enemy_mon3.currenthp = enemy_mon3.hp
		enemy_mon3.turn = 0
		enemy_mon3.reference = "enemy_mon3"
		enemy_mon3.move1cd = 0
		enemy_mon3.move2cd = 0
		enemy_mon3.move3cd = 0
		enemy_mon3.move4cd = 0
		enemy_mon3.status_effects = {}
		enemy_mon3.fainted = false
		msg.post("enemy_mon3#sprite", "play_animation", { id = hash(enemy_mon3.name.."_front_original") })
		combatants["enemy_mon3"] = enemy_mon3
	else
		msg.post("enemy_mon3", "disable")
		msg.post("gui", "disable_mon", {mon = "enemy_mon3"})
	end

	if game_state.enemy_mon4 ~= nil then
		enemy_mon4 = game_state.enemy_mon4
		enemy_mon4.currenthp = enemy_mon4.hp
		enemy_mon4.turn = 0
		enemy_mon4.reference = "enemy_mon4"
		enemy_mon4.move1cd = 0
		enemy_mon4.move2cd = 0
		enemy_mon4.move3cd = 0
		enemy_mon4.move4cd = 0
		enemy_mon4.status_effects = {}
		enemy_mon4.fainted = false
		msg.post("enemy_mon4#sprite", "play_animation", { id = hash(enemy_mon4.name.."_front_original") })
		combatants["enemy_mon4"] = enemy_mon4
	else
		msg.post("enemy_mon4", "disable")
		msg.post("gui", "disable_mon", {mon = "enemy_mon4"})
	end

	if game_state.enemy_boss ~= nil then
		enemy_boss = game_state.enemy_boss
		enemy_boss.currenthp = enemy_boss.hp
		enemy_boss.turn = 0
		enemy_boss.reference = "enemy_boss"
		enemy_boss.move1cd = 0
		enemy_boss.move2cd = 0
		enemy_boss.move3cd = 0
		enemy_boss.move4cd = 0
		enemy_boss.status_effects = {}
		enemy_boss.fainted = false
		
		msg.post("enemy_boss#sprite", "play_animation", { id = hash(enemy_boss.name.."_front_original") })
		combatants["enemy_boss"] = enemy_boss
	else
		msg.post("enemy_boss", "disable")
		msg.post("gui", "disable_mon", {mon = "enemy_boss"})
	end
end

function display_targetting_icons()

	if(#spawned_target_icons > 0) then
		clear_gos(spawned_target_icons)
	end
	
	if(selected_move.targetting == 0) then --self
		local p = go.get_position(current_turn_mon.reference)
		p.y = p.y + 50
		local icon = factory.create("#target_icon_factory",p)
		table.insert(spawned_target_icons, icon)
	elseif(selected_move.targetting == 1) then --enemy
		for i=1,4 do
			if(combatants["enemy_mon"..i] ~= nil and not combatants["enemy_mon"..i].fainted) then
				effectiveness = types.type_effectiveness(selected_move.type, combatants["enemy_mon"..i].type1, combatants["enemy_mon"..i].type2)
				local p = go.get_position("enemy_mon"..i)
				p.y = p.y + 50
				local icon = factory.create("#target_icon_factory",p, nil, {effectiveness = effectiveness})
				table.insert(spawned_target_icons, icon)
			end
		end
		if(game_state.battle_type == 3) then
			effectiveness = types.type_effectiveness(selected_move.type, enemy_boss.type1, enemy_boss.type2)
			local p = go.get_position("enemy_boss")
			p.y = p.y + 128
			local icon = factory.create("#target_icon_factory",p, nil, {effectiveness = effectiveness})
			table.insert(spawned_target_icons, icon)
		end
	elseif(selected_move.targetting == 2) then --ally
		for i=1,4 do
			if(combatants["player_mon"..i] ~= nil and not combatants["player_mon"..i].fainted) then
				local p = go.get_position("player_mon"..i)
				p.y = p.y + 50
				local icon = factory.create("#target_icon_factory",p)
				table.insert(spawned_target_icons, icon)
			end
		end
	end
end

function target_is_valid(target)
	if(selected_move.targetting == 0 and target == current_turn_mon.reference) then
		return true
	elseif(selected_move.targetting == 1 and string.match(target, "^enemy") and not combatants[target].fainted) then
		return true
	elseif(selected_move.targetting == 2 and string.match(target, "^player") and not combatants[target].fainted) then
		return true
	else
		return false
	end
end

function clear_gos(id_table)
	for i, v in ipairs(id_table) do
		go.delete(v)
		id_table[i] = nil
	end
end