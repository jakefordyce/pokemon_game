local game_state = require "common/game_state"
local encounters = require "common/encounters"
local moves = require "common/moves"
local status_effects = require "common/status_effects"
local passive_effects = require "common/passive_effects"
local types = require "common/poke_types"
local enemy_mon1 = nil
local enemy_mon2 = nil
local enemy_mon3 = nil
local enemy_mon4 = nil
local enemy_boss = nil
local selected_move = {}
local selected_move_slot = 1
local spawned_target_icons = {}
local spawned_turn_markers = {}
local current_turn_mon = nil
local combatants = {}
local waiting_for_target = false
local protections = {}
local extra_turn_queue = {}
local move_queue = {}

function init(self)
	msg.post(".", "acquire_input_focus")
	load_data_for_battle()
	msg.post(".", "find_next_turn")
end

function final(self)
end

function update(self, dt)
end

function on_message(self, message_id, message, sender)
	if message_id == hash("move_selected") then
		local move = moves[current_turn_mon.known_moves[message.move].id]
		if(current_turn_mon["move"..message.slot.."cd"] == 0 and (message.slot == 1 or not mon_has_status_effect(current_turn_mon, 23))
		and move.passive == nil) then
			selected_move_slot = message.slot
			selected_move = moves[current_turn_mon.known_moves[message.move].id]
			display_targetting_icons()
			waiting_for_target = true
		else
			waiting_for_target = false
			clear_gos(spawned_target_icons)
		end
	end
	if message_id == hash("target_selected") then
		if(waiting_for_target and target_is_valid(message.target)) then
			--valid target, execute the move and then end the turn.
			waiting_for_target = false
			clear_gos(spawned_target_icons)
			msg.post("gui", "hide_mon_display")
			local move_level = current_turn_mon.known_moves[current_turn_mon["move"..selected_move_slot]].level
			current_turn_mon["move"..selected_move_slot.."cd"] = selected_move.cooldown(move_level)

			local move_to_add = {
				move_user = current_turn_mon,
				target = message.target,
				move_obj = selected_move,
				move_slot = selected_move_slot
			}
			table.insert(move_queue, move_to_add)
			handle_move_queue()
		end
	end
	if message_id == hash("find_next_turn") then
		if current_turn_mon ~= nil then
			msg.post("gui", "update_turn", {target=current_turn_mon.reference, current=current_turn_mon.turn, max=1000})
		end
		if #extra_turn_queue == 0 then
			if combatants["player_mon1"] ~= nil and combatants["player_mon1"].turn > 1000 and not combatants["player_mon1"].fainted then
				combatants["player_mon1"].turn = combatants["player_mon1"].turn - 1000
				current_turn_mon = combatants["player_mon1"]
				start_player_turn(combatants["player_mon1"])
			elseif combatants["player_mon2"] ~= nil and combatants["player_mon2"].turn > 1000 and not combatants["player_mon2"].fainted then
				combatants["player_mon2"].turn = combatants["player_mon2"].turn - 1000
				current_turn_mon = combatants["player_mon2"]
				start_player_turn(combatants["player_mon2"])
			elseif combatants["player_mon3"] ~= nil and combatants["player_mon3"].turn > 1000 and not combatants["player_mon3"].fainted then
				combatants["player_mon3"].turn = combatants["player_mon3"].turn - 1000
				current_turn_mon = combatants["player_mon3"]
				start_player_turn(combatants["player_mon3"])
			elseif combatants["player_mon4"] ~= nil and combatants["player_mon4"].turn > 1000 and not combatants["player_mon4"].fainted then
				combatants["player_mon4"].turn = combatants["player_mon4"].turn - 1000
				current_turn_mon = combatants["player_mon4"]
				start_player_turn(combatants["player_mon4"])
			elseif enemy_boss ~= nil and enemy_boss.turn > 1000 and not enemy_boss.fainted then
				enemy_boss.turn = enemy_boss.turn - 1000
				current_turn_mon = enemy_boss
				start_enemy_turn(enemy_boss)
			elseif enemy_mon1 ~= nil and enemy_mon1.turn > 1000 and not enemy_mon1.fainted then
				enemy_mon1.turn = enemy_mon1.turn - 1000
				current_turn_mon = enemy_mon1
				start_enemy_turn(enemy_mon1)
			elseif enemy_mon2 ~= nil and enemy_mon2.turn > 1000 and not enemy_mon2.fainted then
				enemy_mon2.turn = enemy_mon2.turn - 1000
				current_turn_mon = enemy_mon2
				start_enemy_turn(enemy_mon2)
			elseif enemy_mon3 ~= nil and enemy_mon3.turn > 1000 and not enemy_mon3.fainted then
				enemy_mon3.turn = enemy_mon3.turn - 1000
				current_turn_mon = enemy_mon3
				start_enemy_turn(enemy_mon3)
			elseif enemy_mon4 ~= nil and enemy_mon4.turn > 1000 and not enemy_mon4.fainted then
				enemy_mon4.turn = enemy_mon4.turn - 1000
				current_turn_mon = enemy_mon4
				start_enemy_turn(enemy_mon4)
			else
				timer.delay(.1, false, increment_turns)
			end
		else
			local extra_turn_mon = table.remove(extra_turn_queue)
			if string.match(extra_turn_mon.reference, "^enemy") then
				start_enemy_turn(extra_turn_mon)
			else
				start_player_turn(extra_turn_mon)
			end
		end
	end
	if message_id == hash("end_turn") then
		reduce_status_effect_durations(current_turn_mon, 1, 5)
		clear_gos(spawned_turn_markers)
		msg.post(".", "find_next_turn")
	end
end

-- Learn more: https://defold.com/manuals/input/
function on_input(self, action_id, action)
end

function on_reload(self)
	-- Add reload-handling code here
	-- Learn more: https://defold.com/manuals/hot-reload/
end

function handle_move_queue()
	if(#move_queue > 0 )then
		start_handling_move(move_queue[1])
		table.remove(move_queue, 1)
		timer.delay(1, false, function() handle_move_queue() end)
	else
		msg.post(".", "end_turn")
	end
end

function start_handling_move(move)
	local move_user = move.move_user
	local target = move.target
	local move_obj = move.move_obj
	local move_slot = move.move_slot
	
	local battle_text = ""
	if string.match(move_user.reference, "^enemy") then
		battle_text = "Enemy "
	end
	local hurt_in_confusion = false
	if mon_has_status_effect(move_user, 22) then
		local hurt_rng = math.random(1,100)
		if hurt_rng <= 50 then
			hurt_in_confusion = true
		end
	end

	local level = 0
	
	if hurt_in_confusion then
		msg.post("gui", "set_battle_text", {text = battle_text..move_user.nickname.." hurt itself in confusion!"})
		move_obj = moves[1]
		target = move_user.reference
	else
		msg.post("gui", "set_battle_text", {text = battle_text..move_user.nickname.." used "..move_obj.name.."!"})
		level = move_user.known_moves[move_user["move"..move_slot]].level
	end
	
	local delay_time = 0.0
	
	for index, effect in ipairs(move_obj.effects) do
		if effect.passive == nil then
			local num_of_hits = 1
			if effect.min_hits ~= nil then
				num_of_hits = math.random(effect.min_hits, effect.max_hits)
			end
			for i=1,num_of_hits do
				if effect.target == 0 then --self
					timer.delay(delay_time, false, function() handle_move_effects(level, effect, move_user.reference, move_user, move_obj) end)
				elseif (effect.target == 1 or effect.target == 2) then --enemy, ally, only affect target selected.
					timer.delay(delay_time, false, function() handle_move_effects(level, effect, target, move_user, move_obj) end)
				elseif (effect.target == 3) then -- all enemies
					local effect_target = "^enemy"
					if string.match(move_user.reference, "^enemy") then -- an enemy mon using the move
						effect_target = "^player"
					end
					for i, comb in pairs(combatants) do
						if(string.match(comb.reference, effect_target) and not comb.fainted) then
							timer.delay(delay_time, false, function() handle_move_effects(level, effect, comb.reference, move_user, move_obj) end)
						end
					end
				elseif (effect.target == 4) then -- all allies
					local effect_target = "^player"
					if string.match(move_user.reference, "^enemy") then -- an enemy mon using the move
						effect_target = "^enemy"
					end
					for i, comb in pairs(combatants) do
						if(string.match(comb.reference, effect_target))then-- and not comb.fainted) then
							timer.delay(delay_time, false, function() handle_move_effects(level, effect, comb.reference, move_user, move_obj) end)
						end
					end
				end
				delay_time = delay_time + 0.25
			end
		end
	end

	timer.delay(delay_time, false, function() handle_protections() end)
end

function handle_protections()
	local delay_time = 0
	for index, protection in ipairs(protections) do
		local protector = combatants[protection.protector]
		if not protector.fainted then
			local power = protection.power
			local defense = protector.defense
			if mon_has_status_effect(protector, 4) then
				defense = defense * 0.5
			end
			if mon_has_status_effect(protector, 5) then
				defense = defense * 2
			end
			if protection.ignore_def ~= nil then
				defense = defense * (100 - protection.ignore_def) / 100
			end
			local damage = calc_damage(power, defense)
			timer.delay(delay_time, false, function() damage_defender(protector, damage, false) end)
			timer.delay(delay_time, false, function() display_damage_text(go.get_position(protector.reference), damage, "white") end)
		end
		delay_time = delay_time + 0.3
	end
	for i, v in ipairs(protections) do
		protections[i] = nil
	end
end

function handle_move_effects(level, effect, target, move_user, move_obj)
	local move_type = move_obj.type
	if not combatants[target].fainted or effect.id == 29 then
		effectiveness = types.type_effectiveness(move_type, combatants[target].type1, combatants[target].type2)

		-- Same Type Attack Bonus.
		if(move_type ~= 1 and (move_type == move_user.type1 or move_type == move_user.type2)) then
			effectiveness = effectiveness * 1.25
		end
		
		local damage_text = ""
		local text_color = "white"
		local defender = combatants[target]
		if mon_has_status_effect(defender, 28) and effect_should_reflect(28, effect) then --reflect
			defender = move_user
		end
		
		if effect.id == 1 then --deal damage
			local stat = move_user[effect.param2]
			if string.match(effect.param2, "attack") then
				if mon_has_status_effect(move_user, 2) then
					stat = stat / 2
				elseif mon_has_status_effect(move_user, 3) then
					stat = stat * 1.5
				end
			elseif string.match(effect.param2, "defense") then
				if mon_has_status_effect(move_user, 4) then
					stat = stat / 2
				elseif mon_has_status_effect(move_user, 5) then
					stat = stat * 2
				end
			elseif string.match(effect.param2, "enemy_hp") then
				stat = defender.max_hp
			end
			local power = effect.param1(level) * stat / 100
			if effect.bonus_vs_psn ~= nil and mon_has_status_effect(defender, 15) then
				power = power * effect.bonus_vs_psn
			end
			if effect.bonus_vs_sleep ~= nil and mon_has_status_effect(defender, 11) then
				power = power * effect.bonus_vs_sleep
			end
			if effect.param4 ~= nil then --damage based on multiple stats
				stat = move_user[effect.param4]
				if string.match(effect.param4, "attack") then
					if mon_has_status_effect(move_user, 2) then
						stat = stat / 2
					elseif mon_has_status_effect(move_user, 3) then
						stat = stat * 1.5
					end
					power = power + (effect.param3(level) * stat / 100)
				elseif string.match(effect.param4, "defense") then
					if mon_has_status_effect(move_user, 4) then
						stat = stat / 2
					elseif mon_has_status_effect(move_user, 5) then
						stat = stat * 2
					end
					power = power + (effect.param3(level) * stat / 100)
				elseif string.match(effect.param4, "enemy_hp") then
					stat = defender.max_hp
					power = power + (effect.param3(level) * stat / 100)
				elseif string.match(effect.param4, "speed") then
					local bonus = (effect.param3(level) * stat / 10000) + 1
					power = power * bonus
				end
				
			end
			local defense = defender.defense
			if mon_has_status_effect(defender, 4) then
				defense = defense * 0.5
			end
			if mon_has_status_effect(defender, 5) then
				defense = defense * 2
			end
			if effect.ignore_def ~= nil then
				defense = defense * (100 - effect.ignore_def) / 100
			end
			
			crit_rng = math.random(1,100)
			
			if effect.extra_crit ~= nil then
				crit_rng = crit_rng - effect.extra_crit
			end
			if mon_has_status_effect(move_user, 40) then
				crit_rng = crit_rng - 25
			end
			if crit_rng <= move_user.crit_chance then
				power = math.floor(power * (1 + (move_user.crit_damage / 100)))
				text_color = "yellow"
			end

			if mon_has_status_effect(defender, 6) then
				power = math.floor(power / 10)
				reduce_status_effect_duration(defender, 1, 6)
			end

			if mon_has_status_effect(defender, 34) then
				reduce_status_effect_duration(defender, -1, 34)
			end

			if mon_has_status_effect(defender, 37) then
				power = power * 2
			end

			if effect.extra_damage_user_status ~= nil and mon_has_status_effect(move_user, effect.extra_damage_user_status) then
				power = power + (power * effect.extra_damage_amount / 100)
			end

			if effect.extra_damage_target_status ~= nil and mon_has_status_effect(defender, effect.extra_damage_target_status) then
				power = power + (power * effect.extra_damage_amount / 100)
			end

			if effect.extra_damage_target_status_count ~= nil then
				power = power + (power * mon_count_status_effect(defender, effect.extra_damage_target_status_count) * effect.extra_damage_amount / 100)
			end

			if effect.extra_damage_ally_count ~= nil then
				power = power + (power * mon_count_allies(defender) * effect.extra_damage_ally_count / 100)
			end

			if effect.extra_damage_per_user_charge ~= nil then
				power = power + (power * mon_count_charges(move_user, effect.extra_damage_per_user_charge) * effect.extra_damage_amount / 100)
			end

			protector = mon_protector(defender)
			local damage
			local blocks_revive = effect.blocks_revive or false
			if protector == nil then
				damage = math.floor(calc_damage(power, defense) * effectiveness / 100)
				damage_text = damage
				damage_defender(defender, damage, blocks_revive)
			else
				local share_of_power = math.floor(power / 2)
				damage = math.floor(calc_damage(share_of_power, defense) * effectiveness / 100)
				damage_text = damage
				damage_defender(defender, damage, blocks_revive)
				table.insert(protections, { protector = protector, power = math.ceil(power / 2), ignore_def = effect.ignore_def})
			end
			if effect.leech ~= nil then
				local leech_amount = math.ceil(damage * effect.leech / 100)
				heal_defender(move_user, leech_amount)
				display_damage_text(go.get_position(move_user.reference), leech_amount, "green")
			end
		elseif effect.id == 8 then --increase turn
			local effect_rng = math.random(1,100)
			if effect_rng <= effect.param1(level) then
				local turn_amount = effect.param2 * 10
				damage_text = "turn boost"
				modify_turn_meter(defender, effect.id, turn_amount)
			end
		elseif effect.id == 12 then --decrease turn
			local turn_amount = effect.param2 * -10
			damage_text = "turn reduce"
			if(should_apply_debuff(move_user, effectiveness, defender, effect.param1(level), effect.always_succeeds)) then
				modify_turn_meter(defender, effect.id, turn_amount)
			else
				text_color = "red"
				if mon_has_status_effect(defender, 13) then
					damage_text = "immune"
				else
					damage_text = "resist"
				end
			end
		elseif effect.id == 16 then --heal
			local stat = move_user[effect.param2]
			if string.match(effect.param2, "attack") then
				if mon_has_status_effect(move_user, 2) then
					stat = stat / 2
				elseif mon_has_status_effect(move_user, 3) then
					stat = stat * 1.5
				end
			end
			local power = math.floor(effect.param1(level) * stat / 100)
			
			if mon_has_status_effect(defender, 26) then
				power = 0
			end
			local crit_rng = math.random(1,100)
			text_color = "green"
			if effect.extra_crit ~= nil then
				crit_rng = crit_rng - effect.extra_crit
			end
			if mon_has_status_effect(move_user, 40) then
				crit_rng = crit_rng - 25
			end
			if crit_rng <= move_user.crit_chance then
				power = math.floor(power * (1 + (move_user.crit_damage / 100)))
			end
			damage_text = power
			heal_defender(defender, power)
		elseif effect.id == 19 then --shield
			local stat = move_user[effect.param3]
			local power = math.floor(effect.param4(level) * stat / 100)
			local apply_rng = math.random(1,100)
			if apply_rng <= effect.param1(level) then
				shield_defender(defender, power)
				text_color = "blue"
				damage_text = power
			else
				text_color = "red"
				damage_text = "missed"
			end
		elseif effect.id == 25 then --extra turn
			local effect_rng = math.random(1,100)
			if effect_rng <= effect.param1(level) then
				table.insert(extra_turn_queue, defender)
				damage_text = "Extra Turn"
			end
		elseif effect.id == 29 then --revive
			if defender.fainted then
				if not defender.revive_blocked then
					local power = math.floor(defender.max_hp * effect.param2(level) / 100)
					revive_defender(defender, power)
					damage_text = "revived"
				else
					damage_text = "revive blocked"
				end
			end
		elseif effect.id == 33 then -- remove status effects
			local remove_rng = math.random(1,100)
			if remove_rng <= effect.param1(level) then
				remove_status_effects(defender, effect.param2, effect.param3)
				damage_text = "statuses removed"
			end
		elseif effect.id == 35 then --remove specific status
			local remove_rng = math.random(1,100)
			if remove_rng <= effect.param1(level) then
				remove_status_effect(defender, effect.param2)
				damage_text = "status removed"
			end
		elseif effect.id == 36 then -- lower max hp
			local effect_rng = math.random(1,100)
			if effect_rng <= effect.param1(level) then
				local reduction = 100 - effect.param2
				defender.max_hp = math.ceil(defender.max_hp * reduction / 100)
				if defender.currenthp > defender.max_hp then
					defender.currenthp = defender.max_hp
				end
				msg.post("gui", "update_hp", {target=defender.reference, current=defender.currenthp, max=defender.max_hp, shield=defender.shield})
				damage_text = "reduce max hp"
			end
		elseif effect.id == 38 then -- steal buffs
			local remove_rng = math.random(1,100)
			if remove_rng <= effect.param1(level) then
				copy_status_effects(defender, move_user, effect.param2, effect.param3)
				remove_status_effects(defender, effect.param2, effect.param3)
				damage_text = "buffs stolen"
			end
		elseif effect.id == 39 then -- ally attack
			local effect_rng = math.random(1,100)
			if effect_rng <= effect.param1(level) then
				queue_ally_attacks(move_user, defender)
			end
		elseif status_effects[effect.id] ~= nil and status_effects[effect.id].category > 1 then
			if effect.target == 0 then
				apply_status_effect(defender, effect, move_user)
				damage_text = status_effects[effect.id].damage_text
			elseif should_apply_debuff(move_user, effectiveness, defender, effect.param1(level), effect.always_succeeds) then
				--bosses are not fully affected by loss of control effects. Instead they just lose some turn meter.
				if string.match(defender.reference, 'boss') and status_effects[effect.id].category == 4 then
					damage_text = "turn reduce"
					modify_turn_meter(defender, 12, -100)
				else
					apply_status_effect(defender, effect, move_user)
					damage_text = status_effects[effect.id].damage_text
				end
			else
				text_color = "red"
				if mon_has_status_effect(defender, 13) then
					damage_text = "immune"
				else
					damage_text = "resist"
				end
			end
		elseif status_effects[effect.id] ~= nil and status_effects[effect.id].category == 1 then
			if mon_has_status_effect(defender, 30) then
				text_color = "red"
				damage_text = "immune"
			else
				local buff_rng = math.random(1,100)
				if buff_rng <= effect.param1(level) then
					apply_status_effect(defender, effect, move_user)
					damage_text = status_effects[effect.id].damage_text
				end
			end
		end
		
		display_damage_text(go.get_position(defender.reference),damage_text, text_color)
		
	end
end

function handle_start_turn_passives(mon)
	local damage_text = ""
	local text_color = "white"
	local delay_time = 0.0
	local passive_chance
	for m=1,4 do
		if mon["move"..m] ~= nil then
			local move =  moves[mon.known_moves[mon["move"..m]].id]
			local level = mon.known_moves[mon["move"..m]].level
			for i, effect in ipairs(move.effects) do
				if effect.passive ~= nil and effect.trigger == 1 then
					passive_chance = effect.chance(level)
					if math.random(1,100) <= passive_chance then
						if effect.id == 1 then
							
							reduce_status_effect_durations(mon, 1, 6)
							damage_text = passive_effects[effect.id].damage_text
						end
						timer.delay(delay_time, false, function() display_damage_text(go.get_position(mon.reference),damage_text, text_color) end)
						delay_time = delay_time + 0.25
					end
				end
			end
		end
	end
end

function mon_protector(mon)
	protector = nil
	for i, eff in ipairs(mon.status_effects) do
		if eff.type == 18 then
			protector = eff.placed_by
		end
	end
	return protector
end

function should_apply_debuff(move_user, effectiveness, defender, debuff_chance, always_succeeds)
	if mon_has_status_effect(defender, 13) then
		return false
	end
	accuracy = move_user.accuracy + effectiveness - 100
	if mon_has_status_effect(move_user, 9) then
		accuracy = accuracy / 2
	end
	x = accuracy - defender.resist
	if x < 0 then
		x = 0
	end
	y = defender.resist - accuracy
	if y < 0 then
		y = 0
	end
	chance_to_apply = math.ceil(100 * (1 - 0.25 * (math.pow(0.99, x))) * (math.pow(0.99, y)))
	accuracy_calc_rng = math.random(1,100)
	move_chance_rng = math.random(1,100)

	should_apply = false
	if((accuracy_calc_rng <= chance_to_apply or always_succeeds) and move_chance_rng <= debuff_chance)then
		should_apply = true
	end
	return should_apply
	--return true --DEV: leaving this to make testing debuffs easier
end

function apply_status_effect(defender, effect_obj, move_user)
	if mon_has_status_effect(defender, effect_obj.id) and (status_effects[effect_obj.id].category == 1 or status_effects[effect_obj.id].category == 2)then
		for i, eff in ipairs(defender.status_effects) do
			if eff.type == effect_obj.id then
				if effect_obj.charges ~= nil then
					if effect_obj.charges_stack then
						eff.duration = eff.duration + effect_obj.charges
					else
						eff.duration = effect_obj.charges
					end
				else
					eff.duration = effect_obj.param2
				end
				msg.post(eff.go_id, "update_duration", {duration = eff.duration})
				eff.placed_by = move_user.reference
				if(move_user.reference == defender.reference) then
					eff.ignore_duration_reduction = true
				end
			end
		end
	else
		local effect = {}
		if effect_obj.charges ~= nil then
			effect.has_charges = true
			effect.duration = effect_obj.charges
		else
			effect.duration = effect_obj.param2
		end
		effect.category = status_effects[effect_obj.id].category
		effect.type = effect_obj.id
		effect.placed_by = move_user.reference
		--if someone is applying a buff to themself then mark it to not reduce its duration at the end of this turn.
		if(move_user.reference == defender.reference) then --status_effects[effect_id].category == 1 and
			effect.ignore_duration_reduction = true
		else
			effect.ignore_duration_reduction = false
		end
		local p = go.get_position(defender.reference)
		p.y = p.y + 125
		p.x = p.x - 10
		local effect_go = factory.create("#status_effect_factory",p, nil, {duration = effect.duration, image = hash(status_effects[effect_obj.id].sprite_name)})
		effect.go_id = effect_go
		table.insert(defender.status_effects, effect)
		position_status_effects(defender)
	end
end

-- type
-- 0 = all
-- -1 = harmful
-- -2 = helpful
function remove_status_effects(mon, num_of_effects, type)
	local status_effects_to_remove = {}
	local effects_removed = 0
	for i, eff in ipairs(mon.status_effects) do
		if(type == 0) then
			if effects_removed < num_of_effects or num_of_effects == 0 then
				eff.duration = 0
				msg.post(eff.go_id, "update_duration", {duration = eff.duration})
				table.insert(status_effects_to_remove, 1, i)
				effects_removed = effects_removed + 1
			end
		elseif(type == -1 and (eff.category == 2 or eff.category == 3 or eff.category == 4)) then
			if effects_removed < num_of_effects or num_of_effects == 0 then
				eff.duration = 0
				msg.post(eff.go_id, "update_duration", {duration = eff.duration})
				table.insert(status_effects_to_remove, 1, i)
				effects_removed = effects_removed + 1
			end
		elseif(type == -2 and (eff.category == 1 or eff.category == 5)) then
			if effects_removed < num_of_effects or num_of_effects == 0 then
				eff.duration = 0
				msg.post(eff.go_id, "update_duration", {duration = eff.duration})
				table.insert(status_effects_to_remove, 1, i)
				effects_removed = effects_removed + 1
			end
		end
	end
	for i, setr in ipairs(status_effects_to_remove) do
		table.remove(mon.status_effects, setr)
	end
	position_status_effects(mon)
end

-- type
-- 0 = all
-- -1 = harmful
-- -2 = helpful
function copy_status_effects(effect_source_mon, effect_target_mon, num_of_effects, type)
	local effects_copied = 0
	for i, eff in ipairs(effect_source_mon.status_effects) do
		if(type == 0) or
		(type == -1 and (eff.category == 2 or eff.category == 3 or eff.category == 4)) or
		(type == -2 and (eff.category == 1 or eff.category == 5)) then
			if effects_copied < num_of_effects or num_of_effects == 0 then
				local effect_obj = {}
				effect_obj.id = eff.type
				effect_obj.param2 = eff.duration
				effect_obj.charges = eff.charges
				effect_obj.charges_stack = eff.charges_stack
				
				apply_status_effect(effect_target_mon, effect_obj, combatants[eff.placed_by])
				effects_copied = effects_copied + 1
			end
		end
	end
end

function remove_status_effect(mon, effect_id)
	local status_effects_to_remove = {}

	if effect_id == 19 then
		mon.shield = 0
		msg.post("gui", "update_hp", {target = mon.reference, current=mon.currenthp, max=mon.max_hp, shield=mon.shield})
	else
		for i, eff in ipairs(mon.status_effects) do
			if(eff.type == effect_id) then
				eff.duration = 0
				msg.post(eff.go_id, "update_duration", {duration = eff.duration})
				table.insert(status_effects_to_remove, 1, i)
			end
		end
		for i, setr in ipairs(status_effects_to_remove) do
			table.remove(mon.status_effects, setr)
		end
		position_status_effects(mon)
	end
	
end

function modify_turn_meter(defender, effect_id, amount)
	defender.turn = defender.turn + amount
	if defender.turn < 0 then
		defender.turn = 0
	end
	msg.post("gui", "update_turn", {target=defender.reference, current=defender.turn, max=1000})
end

function display_damage_text(position, text, text_color)
	local damage_text = factory.create("#effect_text_factory", position, nil)
	msg.post(damage_text, "set_values", {label_text = text, label_color = text_color})
end

function position_status_effects(mon)
	local p = go.get_position(mon.reference)
	p.y = p.y + 125
	p.x = p.x - 24
	p.z = 0.6
	local original_x = p.x
	local effect_count = 0
	for i, eff in ipairs(mon.status_effects) do
		go.set_position(p, eff.go_id)
		p.x = p.x + 32
		effect_count = effect_count + 1
		if effect_count > 3 and not string.match(mon.reference, "boss") then
			p.x = original_x
			p.y = p.y + 32
			effect_count = 0
		end
	end
end

-- Categories
-- 1 = buff - increase stats
-- 2 = debuff - decrease stats
-- 3 = torment - takes damage each round
-- 4 = loss of control - prevents actions in some way
-- 5 = 1, 2, and 4  i.e. end of turn
-- 6 = 2, 3, and 4  i.e. debuff cleanse from ally
function reduce_status_effect_durations(mon, dur, category)
	local status_effects_to_remove = {}
	for i, eff in ipairs(mon.status_effects) do
		if(category == 5 and eff.ignore_duration_reduction) then
			--prevent a pokemon who just buffed themself from immediately losing a turn of the buff at the end of their turn.
			eff.ignore_duration_reduction = false
		elseif not eff.has_charges then
			if(category == 5 and eff.category ~= 3) or (category == 6 and eff.category ~= 1) or (category == eff.category) then
				eff.duration = eff.duration - dur
				msg.post(eff.go_id, "update_duration", {duration = eff.duration})
				if eff.duration < 1 then
					table.insert(status_effects_to_remove, 1, i)
				end
			end
		end
	end
	for i, setr in ipairs(status_effects_to_remove) do
		table.remove(mon.status_effects, setr)
	end
	position_status_effects(mon)
end

function reduce_status_effect_duration(mon, dur, effect_id)
	local status_effects_to_remove = {}
	for i, eff in ipairs(mon.status_effects) do
		if(eff.type == effect_id) then
			eff.duration = eff.duration - dur
			msg.post(eff.go_id, "update_duration", {duration = eff.duration})
			if eff.duration < 1 then
				table.insert(status_effects_to_remove, 1, i)
			end
		end
	end
	for i, setr in ipairs(status_effects_to_remove) do
		table.remove(mon.status_effects, setr)
	end
	position_status_effects(mon)
end

function effect_should_reflect(reflect_type, effect_obj)
	local should_reflect = true
	
	if effect_obj.id == 1 or effect_obj.id == 12 then
		should_reflect = true
	elseif effect_obj.id == 8 or effect_obj.id == 16 or effect_obj.id == 19 or effect_obj.id == 25 or effect_obj.id == 32 or
	effect_obj.id == 33 or effect_obj.id == 35 or effect_obj.id == 38 then
		should_reflect = false
	elseif status_effects[effect_obj.id].category > 1 then
		should_reflect = true
	else
		should_reflect = false
	end

	return should_reflect
end

--effect_ids
-- 0 = any status effect, good or bad
-- -1 = buff
-- -2 = debuff
-- -3 = torment
-- -4 = loss of control
function mon_has_status_effect(mon, effect_id)
	local has_status_effect = false
	for i, eff in ipairs(mon.status_effects) do
		local cat = status_effects[eff.type].category
		if eff.type == effect_id or (math.abs(effect_id) == cat) or effect_id == 0 then
			has_status_effect = true
		end
	end
	return has_status_effect
end


--effect_ids
-- 0 = any status effect, good or bad
-- -1 = any harmful effect
function mon_count_status_effect(mon, effect_id)
	local effect_count = 0
	for i, eff in ipairs(mon.status_effects) do
		local cat = status_effects[eff.type].category
		if eff.type == effect_id or effect_id == 0 
		or (effect_id == -1 and (cat==2 or cat==3 or cat==4)) then
			effect_count = effect_count + 1
		end
	end
	return effect_count
end

function mon_count_allies(mon)
	local ally_count = 0
	local effect_target = "^player"
	if string.match(mon.reference, "^enemy") then -- an enemy mon using the move
		effect_target = "^enemy"
	end
	for i, comb in pairs(combatants) do
		if(string.match(comb.reference, effect_target) and not comb.fainted) then
			ally_count = ally_count + 1
		end
	end
	return ally_count - 1
end

function queue_ally_attacks(move_user, defender)
	local effect_target = "^player"
	if string.match(move_user.reference, "^enemy") then -- an enemy mon using the move
		effect_target = "^enemy"
	end
	for i, comb in pairs(combatants) do
		if(string.match(comb.reference, effect_target) and not comb.fainted) then
			local pending_attack = {
				move_user = comb,
				move_obj = moves[comb.known_moves[comb.move1].id],
				move_slot = 1,
				target = defender.reference
			}
			table.insert(move_queue, pending_attack)
		end
	end
end

function mon_count_charges(mon, effect_id)
	local charge_count = 0
	for i, eff in ipairs(mon.status_effects) do
		if eff.type == effect_id then
			charge_count = charge_count + eff.duration
		end
	end
	return charge_count
end

function mon_can_act(mon)
	local can_act = true
	for i, eff in ipairs(mon.status_effects) do
		if eff.category == 4 and (eff.type ~= 22 and eff.type ~= 23) then --loss of control
			can_act = false
		end
	end
	return can_act
end

function damage_defender(defender, damage, blocks_revive)
	local shield_amount = defender.shield
	local remaining_damage = damage - shield_amount
	defender.shield = defender.shield - damage
	if defender.shield < 0 then
		defender.shield = 0
	end
	if remaining_damage > 0 then
		defender.currenthp = defender.currenthp - damage
	end
	--taking damage wakes up a sleeping pokemon
	for i, eff in ipairs(defender.status_effects) do
		if eff.type == 11 then
			go.delete(eff.go_id)
			table.remove(defender.status_effects, i)
		end
	end
	
	if defender.currenthp <= 0 then
		defender.currenthp = 0
		defender.fainted = true
		defender.turn = 0
		if blocks_revive then
			defender.revive_blocked = true
		end
		msg.post("gui", "disable_mon", {mon = defender.reference})
		msg.post(defender.reference.."#sprite", "disable")
		for i, eff in ipairs(defender.status_effects) do
			go.delete(eff.go_id)
			defender.status_effects[i] = nil
		end
	else
		msg.post("gui", "update_hp", {target=defender.reference, current=defender.currenthp, max=defender.max_hp, shield=defender.shield})
	end

	if enemies_are_fainted() then
		timer.delay(0.5, false, function() msg.post("main:/loader#main", "end_battle", {victory = true}) end)
	elseif player_mons_are_fainted() then
		timer.delay(0.5, false, function() msg.post("main:/loader#main", "end_battle", {victory = false}) end)
	end
end

function revive_defender(defender, damage)
	heal_defender(defender, damage)
	defender.fainted = false
	defender.turn = 0
	msg.post("gui", "enable_mon", {mon = defender.reference})
	msg.post(defender.reference.."#sprite", "enable")
end

function heal_defender(defender, damage)
	defender.currenthp = defender.currenthp + damage
	if defender.currenthp > defender.max_hp then
		defender.currenthp = defender.max_hp
	end
	msg.post("gui", "update_hp", {target=defender.reference, current=defender.currenthp, max=defender.max_hp, shield=defender.shield})
end

function shield_defender(defender, damage)
	if damage > defender.shield then
		defender.shield = damage
	end
	msg.post("gui", "update_hp", {target = defender.reference, current=defender.currenthp, max=defender.max_hp, shield=defender.shield})
end

function enemies_are_fainted()
	fainted = false
	if game_state.battle_type == 3 then --boss fight
		fainted = enemy_boss.fainted
	else
		fainted = (enemy_mon1 == nil or enemy_mon1.fainted) 
		and (enemy_mon2 == nil or enemy_mon2.fainted) 
		and (enemy_mon3 == nil or enemy_mon3.fainted) 
		and (enemy_mon4 == nil or enemy_mon4.fainted)
	end
	return fainted
end

function player_mons_are_fainted()
	fainted = (combatants["player_mon1"] == nil or combatants["player_mon1"].fainted) and 
	(combatants["player_mon2"] == nil or combatants["player_mon2"].fainted) and 
		(combatants["player_mon3"] == nil or combatants["player_mon3"].fainted) and 
		(combatants["player_mon4"] == nil or combatants["player_mon4"].fainted)

	return fainted
end

function calc_damage(power, defense)
	modded_def = defense * 400 / (400 + defense)
	damage_modifier = 100 / (100 + modded_def)
	return math.ceil(power * damage_modifier)
end

function reduce_all_cooldowns(mon, amount)
	for i=1,4 do
		mon["move"..i.."cd"] = mon["move"..i.."cd"] - amount
		if mon["move"..i.."cd"] < 0 then
			mon["move"..i.."cd"] = 0
		end
	end
end

function activate_torments(turn_mon)
	local delay_time = 0
	for i, eff in ipairs(turn_mon.status_effects) do
		if(eff.category == 3) then
			local damage = math.ceil(turn_mon.max_hp * 5 / 100)
			if mon_has_status_effect(turn_mon, 6) then
				damage = math.floor(damage / 10)
			end
			local damage_text = damage
			damage_defender(turn_mon, damage, false)
			timer.delay(delay_time, false, function() display_damage_text(go.get_position(turn_mon.reference),damage_text, "white") end)
			
			if eff.type == 17 then
				if mon_has_status_effect(combatants[eff.placed_by], 26) then
					damage = 0 --this variable should have already been used to deal damage by this point.
				end
				heal_defender(combatants[eff.placed_by], damage)
				timer.delay(delay_time, false, function() display_damage_text(go.get_position(eff.placed_by),damage_text, "green") end)
			end
			delay_time = delay_time + 0.2
		end
	end
end

function activate_blessings(turn_mon)
	local delay_time = 0
	for i, eff in ipairs(turn_mon.status_effects) do
		if(eff.category == 5) then
			local damage = math.ceil(turn_mon.max_hp * 5 / 100)
			if mon_has_status_effect(turn_mon, 26) then
				damage = 0
			end
			local damage_text = damage
			heal_defender(turn_mon, damage)
			timer.delay(delay_time, false, function() display_damage_text(go.get_position(turn_mon.reference),damage_text, "green") end)
			delay_time = delay_time + 0.2
		end
	end
end

function load_data_for_battle()
	load_player_mon_data()
	load_enemy_data()
end

function start_player_turn(turn_mon)
	reduce_all_cooldowns(turn_mon, 1)
	activate_blessings(turn_mon)
	handle_start_turn_passives(turn_mon)
	activate_torments(turn_mon)
	reduce_status_effect_durations(turn_mon, 1, 3)
	local p = go.get_position(turn_mon.reference)
	p.y = p.y - 60
	p.z = p.z - 1
	local turn_marker = factory.create("#turn_marker_factory",p, nil, nil, 2.0)
	table.insert(spawned_turn_markers, turn_marker)
	
	if mon_can_act(turn_mon) and not turn_mon.fainted then
		local cooldowns_blocked = mon_has_status_effect(turn_mon, 23)
		local mon_data = {
			mon_reference = turn_mon.reference,
			move1cd = turn_mon.move1cd,
			move2cd = turn_mon.move2cd,
			move3cd = turn_mon.move3cd,
			move4cd = turn_mon.move4cd
		}
		msg.post("gui", "display_mon", { mon = mon_data, cooldowns_blocked = cooldowns_blocked })
	else
		timer.delay(.5, false, function() msg.post(".", "end_turn") end)
	end
end

function start_enemy_turn(turn_mon)
	if not player_mons_are_fainted() then
		reduce_all_cooldowns(turn_mon, 1)
		activate_blessings(turn_mon)
		activate_torments(turn_mon)
		reduce_status_effect_durations(turn_mon, 1, 3)
		local p = go.get_position(turn_mon.reference)
		p.z = p.z - 1
		scale = (string.match(turn_mon.reference, "boss") and 4 or 2)
		yshift = (string.match(turn_mon.reference, "boss") and 128 or 32)
		p.y = p.y - yshift
		local turn_marker = factory.create("#turn_marker_factory",p, nil, nil, scale)
		table.insert(spawned_turn_markers, turn_marker)
		
		if mon_can_act(turn_mon) and not turn_mon.fainted then
			timer.delay(1, false, choose_enemy_move)
			--timer.delay(2, false, function() msg.post(".", "end_turn") end)
		else
			timer.delay(.5, false, function() msg.post(".", "end_turn") end)
		end
	end
end

function choose_enemy_move()
	local target = ""
	if mon_has_status_effect(current_turn_mon, 23) then --cooldowns are blocked, can only use default.
		selected_move = moves[current_turn_mon.known_moves[current_turn_mon["move1"]].id]
		selected_move_slot = 1
	else
		local is_move_chosen = false
		if(current_turn_mon.move_priority == nil) then --wild encounters or bad trainers
			while is_move_chosen == false do
				random_move = math.random(1,4) -- choose a move at random
				-- see if the move is off cooldown
				if(current_turn_mon["move"..random_move] ~= nil and current_turn_mon["move"..random_move.."cd"] == 0 and moves[current_turn_mon.known_moves[current_turn_mon["move"..random_move]].id].passive == nil) then
					selected_move = moves[current_turn_mon.known_moves[current_turn_mon["move"..random_move]].id]
					selected_move_slot = random_move
					is_move_chosen = true
					local move_level = current_turn_mon.known_moves[current_turn_mon["move"..random_move]].level
					current_turn_mon["move"..random_move.."cd"] = current_turn_mon["move"..random_move.."cd"] + selected_move.cooldown(move_level)
				end
			end
		else -- bosses and good trainers
			local i = 1
			while is_move_chosen == false do
				local priority_move = current_turn_mon.move_priority[i]
				local move = moves[current_turn_mon.known_moves[current_turn_mon["move"..priority_move]].id]
				if current_turn_mon["move"..priority_move.."cd"] == 0 and move.passive == nil then
					selected_move = moves[current_turn_mon.known_moves[current_turn_mon["move"..priority_move]].id]
					selected_move_slot = priority_move
					is_move_chosen = true
					local move_level = current_turn_mon.known_moves[current_turn_mon["move"..priority_move]].level
					current_turn_mon["move"..priority_move.."cd"] = current_turn_mon["move"..priority_move.."cd"] + selected_move.cooldown(move_level)
				else
					i = i + 1
				end
			end
		end
	end
	

	is_target_chosen = false
	local target_chosen
	if selected_move.targetting == 0 then
		target = current_turn_mon.reference
	elseif selected_move.targetting == 1 then
		while is_target_chosen == false do
			target_chosen = math.random(1,4)
			if(combatants["player_mon"..target_chosen] ~= nil and not combatants["player_mon"..target_chosen].fainted) then
				target = combatants["player_mon"..target_chosen].reference
				is_target_chosen = true
			end
		end
	elseif selected_move.targetting == 2 then
		local target_chosen = math.random(1,4)
		target = combatants["enemy_mon"..target_chosen].reference
	end

	local move_to_add = {
		move_user = current_turn_mon,
		target = target,
		move_obj = selected_move,
		move_slot = selected_move_slot
	}
	table.insert(move_queue, move_to_add)
	handle_move_queue()
	--start_handling_move(target)
end

function increment_mon_turn(mon)
	if mon ~= nil and not mon.fainted then
		local speed = mon.speed
		if mon_has_status_effect(mon, 7) then
			speed = speed * 1.3
		end
		if mon_has_status_effect(mon, 10) or mon_has_status_effect(mon, 24) then
			speed = speed / 1.3
		end
		mon.turn = mon.turn + speed
		msg.post("gui", "update_turn", {target=mon.reference, current=mon.turn, max=1000})
	end
end

function increment_turns()
	local mon = {}
	for i=1,4 do
		mon = combatants["player_mon"..i]
		increment_mon_turn(mon)
		mon = combatants["enemy_mon"..i]
		increment_mon_turn(mon)
	end
	mon = combatants["enemy_boss"]
	increment_mon_turn(mon)
	
	msg.post(".", "find_next_turn")
end

function load_player_mon_data()
	for i=1,4 do
		if game_state["player_mon"..i] ~= nil then
			local mon = game_state.pokemon[game_state["player_mon"..i]]
			combatants["player_mon"..i] = mon
			combatants["player_mon"..i].currenthp = mon.hp
			combatants["player_mon"..i].max_hp = mon.hp
			combatants["player_mon"..i].shield = 0
			combatants["player_mon"..i].turn = 0
			combatants["player_mon"..i].reference = "player_mon"..i
			combatants["player_mon"..i].move1cd = 0
			combatants["player_mon"..i].move2cd = 0
			combatants["player_mon"..i].move3cd = 0
			combatants["player_mon"..i].move4cd = 0
			combatants["player_mon"..i].status_effects = {}
			combatants["player_mon"..i].fainted = false
			combatants["player_mon"..i].passive_effects = {}
			msg.post("player_mon"..i.."#sprite", "play_animation", { id = hash(mon.name.."_back_original") })
		else
			msg.post("player_mon"..i, "disable")
			msg.post("gui", "disable_mon", {mon = "player_mon"..i})
		end
	end
end

function load_enemy_data()
	if game_state.enemy_mon1 ~= nil then
		enemy_mon1 = game_state.enemy_mon1
		enemy_mon1.currenthp = enemy_mon1.hp
		enemy_mon1.max_hp = enemy_mon1.hp
		enemy_mon1.shield = 0
		enemy_mon1.turn = 0
		enemy_mon1.reference = "enemy_mon1"
		enemy_mon1.move1cd = 0
		enemy_mon1.move2cd = 0
		enemy_mon1.move3cd = 0
		enemy_mon1.move4cd = 0
		enemy_mon1.status_effects = {}
		enemy_mon1.fainted = false
		msg.post("enemy_mon1#sprite", "play_animation", { id = hash(enemy_mon1.name.."_front_original") })
		combatants["enemy_mon1"] = enemy_mon1
	else
		msg.post("enemy_mon1", "disable")
		msg.post("gui", "disable_mon", {mon = "enemy_mon1"})
	end

	if game_state.enemy_mon2 ~= nil then
		enemy_mon2 = game_state.enemy_mon2
		enemy_mon2.currenthp = enemy_mon2.hp
		enemy_mon2.max_hp = enemy_mon2.hp
		enemy_mon2.shield = 0
		enemy_mon2.turn = 0
		enemy_mon2.reference = "enemy_mon2"
		enemy_mon2.move1cd = 0
		enemy_mon2.move2cd = 0
		enemy_mon2.move3cd = 0
		enemy_mon2.move4cd = 0
		enemy_mon2.status_effects = {}
		enemy_mon2.fainted = false
		msg.post("enemy_mon2#sprite", "play_animation", { id = hash(enemy_mon2.name.."_front_original") })
		combatants["enemy_mon2"] = enemy_mon2
	else
		msg.post("enemy_mon2", "disable")
		msg.post("gui", "disable_mon", {mon = "enemy_mon2"})
	end

	if game_state.enemy_mon3 ~= nil then
		enemy_mon3 = game_state.enemy_mon3
		enemy_mon3.currenthp = enemy_mon3.hp
		enemy_mon3.max_hp = enemy_mon3.hp
		enemy_mon3.shield = 0
		enemy_mon3.turn = 0
		enemy_mon3.reference = "enemy_mon3"
		enemy_mon3.move1cd = 0
		enemy_mon3.move2cd = 0
		enemy_mon3.move3cd = 0
		enemy_mon3.move4cd = 0
		enemy_mon3.status_effects = {}
		enemy_mon3.fainted = false
		msg.post("enemy_mon3#sprite", "play_animation", { id = hash(enemy_mon3.name.."_front_original") })
		combatants["enemy_mon3"] = enemy_mon3
	else
		msg.post("enemy_mon3", "disable")
		msg.post("gui", "disable_mon", {mon = "enemy_mon3"})
	end

	if game_state.enemy_mon4 ~= nil then
		enemy_mon4 = game_state.enemy_mon4
		enemy_mon4.currenthp = enemy_mon4.hp
		enemy_mon4.max_hp = enemy_mon4.hp
		enemy_mon4.shield = 0
		enemy_mon4.turn = 0
		enemy_mon4.reference = "enemy_mon4"
		enemy_mon4.move1cd = 0
		enemy_mon4.move2cd = 0
		enemy_mon4.move3cd = 0
		enemy_mon4.move4cd = 0
		enemy_mon4.status_effects = {}
		enemy_mon4.fainted = false
		msg.post("enemy_mon4#sprite", "play_animation", { id = hash(enemy_mon4.name.."_front_original") })
		combatants["enemy_mon4"] = enemy_mon4
	else
		msg.post("enemy_mon4", "disable")
		msg.post("gui", "disable_mon", {mon = "enemy_mon4"})
	end

	if game_state.enemy_boss ~= nil then
		enemy_boss = game_state.enemy_boss
		enemy_boss.currenthp = enemy_boss.hp
		enemy_boss.max_hp = enemy_boss.hp
		enemy_boss.shield = 0
		enemy_boss.turn = 0
		enemy_boss.reference = "enemy_boss"
		enemy_boss.move1cd = 0
		enemy_boss.move2cd = 0
		enemy_boss.move3cd = 0
		enemy_boss.move4cd = 0
		enemy_boss.status_effects = {}
		enemy_boss.fainted = false
		
		msg.post("enemy_boss#sprite", "play_animation", { id = hash(enemy_boss.name.."_front_original") })
		combatants["enemy_boss"] = enemy_boss
	else
		msg.post("enemy_boss", "disable")
		msg.post("gui", "disable_mon", {mon = "enemy_boss"})
	end
end

function display_targetting_icons()

	if(#spawned_target_icons > 0) then
		clear_gos(spawned_target_icons)
	end
	
	if(selected_move.targetting == 0) then --self
		local p = go.get_position(current_turn_mon.reference)
		p.y = p.y + 50
		local icon = factory.create("#target_icon_factory",p)
		table.insert(spawned_target_icons, icon)
	elseif(selected_move.targetting == 1) then --enemy
		for i=1,4 do
			if(combatants["enemy_mon"..i] ~= nil and not combatants["enemy_mon"..i].fainted) then
				effectiveness = types.type_effectiveness(selected_move.type, combatants["enemy_mon"..i].type1, combatants["enemy_mon"..i].type2)
				local p = go.get_position("enemy_mon"..i)
				p.y = p.y + 50
				local icon = factory.create("#target_icon_factory",p, nil, {effectiveness = effectiveness})
				table.insert(spawned_target_icons, icon)
			end
		end
		if(game_state.battle_type == 3) then
			effectiveness = types.type_effectiveness(selected_move.type, enemy_boss.type1, enemy_boss.type2)
			local p = go.get_position("enemy_boss")
			p.y = p.y + 100
			p.z = 1
			local icon = factory.create("#target_icon_factory",p, nil, {effectiveness = effectiveness})
			table.insert(spawned_target_icons, icon)
		end
	elseif(selected_move.targetting == 2) then --ally
		for i=1,4 do
			if(combatants["player_mon"..i] ~= nil and not combatants["player_mon"..i].fainted) then
				local p = go.get_position("player_mon"..i)
				p.y = p.y + 50
				local icon = factory.create("#target_icon_factory",p)
				table.insert(spawned_target_icons, icon)
			end
		end
	end
end

function target_is_valid(target)
	if(selected_move.targetting == 0 and target == current_turn_mon.reference) then
		return true
	elseif(selected_move.targetting == 1 and string.match(target, "^enemy") and not combatants[target].fainted) then
		return true
	elseif(selected_move.targetting == 2 and string.match(target, "^player") and not combatants[target].fainted) then
		return true
	else
		return false
	end
end

function clear_gos(id_table)
	for i, v in ipairs(id_table) do
		go.delete(v)
		id_table[i] = nil
	end
end