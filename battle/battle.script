local game_state = require "common/game_state"
local encounters = require "common/encounters"
local moves = require "common/moves"
local player_mon1 = {}
local player_mon2 = nil
local player_mon3 = nil
local player_mon4 = nil
local enemy_mon1 = {}
local selected_move = {}
local spawned_target_icons = {}
local spawned_turn_markers = {}
local current_turn_mon = nil
local combatants = {}

function init(self)
	msg.post(".", "acquire_input_focus")
	load_data_for_battle()
	msg.post(".", "find_next_turn")
end

function final(self)
	-- Add finalization code here
	-- Learn more: https://defold.com/manuals/script/
end

function update(self, dt)
	
end

-- Learn more: https://defold.com/manuals/message-passing/
function on_message(self, message_id, message, sender)
	if message_id == hash("move_selected") then
		selected_move = moves[current_turn_mon.known_moves[message.move].id]
		display_targetting_icons()
	end
	if message_id == hash("target_selected") then
		if(target_is_valid(message.target)) then
			--valid target, execute the move and then end the turn.
			clear_gos(spawned_target_icons)
			msg.post("gui", "hide_mon_display")
			start_handling_move(message.target)
			timer.delay(1, false, function() msg.post(".", "end_turn") end)
		end
	end
	if message_id == hash("find_next_turn") then
		if current_turn_mon ~= nil then
			msg.post("gui", "update_turn", {target=current_turn_mon.reference, current=current_turn_mon.turn, max=1000})
		end
		if player_mon1.turn > 1000 then
			player_mon1.turn = player_mon1.turn - 1000
			current_turn_mon = player_mon1
			start_player_turn(player_mon1)
		elseif player_mon2 ~= nil and player_mon2.turn > 1000 then
			player_mon2.turn = player_mon2.turn - 1000
			current_turn_mon = player_mon2
			start_player_turn(player_mon2)
		elseif player_mon3 ~= nil and player_mon3.turn > 1000 then
			player_mon3.turn = player_mon3.turn - 1000
			current_turn_mon = player_mon3
			start_player_turn(player_mon3)
		elseif player_mon4 ~= nil and player_mon4.turn > 1000 then
			player_mon4.turn = player_mon4.turn - 1000
			current_turn_mon = player_mon4
			start_player_turn(player_mon4)
		elseif enemy_mon1.turn > 1000 then
			enemy_mon1.turn = enemy_mon1.turn - 1000
			current_turn_mon = enemy_mon1
			start_enemy_turn(enemy_mon1)
		else
			timer.delay(.1, false, increment_turn)
		end
	end
	if message_id == hash("end_turn") then
		clear_gos(spawned_turn_markers)
		msg.post(".", "find_next_turn")
	end
end

-- Learn more: https://defold.com/manuals/input/
function on_input(self, action_id, action)
end

function on_reload(self)
	-- Add reload-handling code here
	-- Learn more: https://defold.com/manuals/hot-reload/
end

function start_handling_move(target)
	local battle_text = ""
	if string.match(current_turn_mon.reference, "^enemy") then
		battle_text = "Enemy "
	end
	msg.post("gui", "set_battle_text", {text = battle_text..current_turn_mon.name.." used "..selected_move.name.."!"})
	for index, effect in ipairs(selected_move.effects) do
		handle_move_effects(effect, target, current_turn_mon)
	end
end

function handle_move_effects(effect, target, move_user)
	if effect.id == 1 then --deal damage
		local defender = combatants[target]
		stat = move_user[effect.param2]
		if mon_has_buff_debuff_type(move_user, 2) then
			stat = stat / 2
		end	
		local power = effect.param1 * stat / 100
		local damage = calc_damage(power, defender.defense)
		damage_defender(defender, damage)
	end
	if effect.id == 2 then --reduce attack
		local defender = combatants[target]
		local duration = effect.param2
		apply_debuff(defender, 2, duration)
	end
end

function apply_debuff(defender, debuff_type, duration)
	debuff = {}
	debuff.duration = duration
	debuff.category = 2
	debuff.type = debuff_type
	p = go.get_position(defender.reference)
	p.y = p.y + 125
	p.x = p.x - 10
	debuff_go = factory.create("#buff_debuff_factory",p, nil, {duration = duration})
	debuff.go_id = debuff_go
	table.insert(defender.buffs_debuffs, debuff)
end

function mon_has_buff_debuff_type(mon, buff_debuff_type)
	has_buff_debuff = false
	for i, bd in ipairs(mon.buffs_debuffs) do
		if bd.type == buff_debuff_type then
			has_buff_debuff = true
		end
	end
	return has_buff_debuff
end

function damage_defender(defender, damage)
	defender.currenthp = defender.currenthp - damage

	p = go.get_position(defender.reference)
	damage_text = factory.create("#effect_text_factory",p, nil)
	msg.post(damage_text, "set_values", {label_text=""..damage, label_color="grey"})
	
	if defender.currenthp <= 0 then
		defender.currenthp = 0
	end
	-- prompt damage numbers to appear on screen
	msg.post("gui", "update_hp", {target=defender.reference, current=defender.currenthp, max=defender.hp})
	-- check if dead

	--TODO: check all instead of just one. Possibly find a better place for this check?
	if defender.currenthp <= 0 then
		msg.post("main:/loader#main", "end_battle")
	end
end

function calc_damage(power, defense)
	return math.ceil((200 / (200 + defense) * power))
end

function load_data_for_battle()
	load_player_mon_data()
	load_enemy_data()
end

function start_player_turn(turn_mon)
	msg.post("gui", "display_mon", {mon = turn_mon})
	local p = go.get_position(turn_mon.reference)
	p.y = p.y - 60
	p.z = p.z - 1
	local turn_marker = factory.create("#turn_marker_factory",p, nil, nil, 2.0)
	table.insert(spawned_turn_markers, turn_marker)
end

function start_enemy_turn(turn_mon)
	local p = go.get_position(turn_mon.reference)
	p.y = p.y - 60
	p.z = p.z - 1
	local turn_marker = factory.create("#turn_marker_factory",p, nil, nil, 1.5)
	table.insert(spawned_turn_markers, turn_marker)
	timer.delay(1, false, choose_enemy_move)
	timer.delay(2, false, function() msg.post(".", "end_turn") end)
end

function choose_enemy_move()
	is_move_chosen = false
	local target = ""
	while is_move_chosen == false do
		random_move = math.random(1,4) -- choose a move at random
		-- see if the move is off cooldown
		if(current_turn_mon["move"..random_move.."cd"] == 0) then
			selected_move = moves[current_turn_mon.known_moves[current_turn_mon["move"..random_move]].id]
			is_move_chosen = true
		end
	end

	is_target_chosen = false
	local target_chosen
	if selected_move.targetting == 0 then
		target = current_turn_mon.reference
	elseif selected_move.targetting == 1 then
		while is_target_chosen == false do
			target_chosen = math.random(1,4)
			if(combatants["player_mon"..target_chosen] ~= nil) then
				target = combatants["player_mon"..target_chosen].reference
				is_target_chosen = true
			end
		end
	elseif selected_move.targetting == 2 then
		local target_chosen = math.random(1,4)
		target = combatants["enemy_mon"..target_chosen].reference
	end
	
	start_handling_move(target)
end

function increment_turn()
	player_mon1.turn = player_mon1.turn + player_mon1.speed
	msg.post("gui", "update_turn", {target="player_mon1", current=player_mon1.turn, max=1000})
	if player_mon2 ~= nil then
		player_mon2.turn = player_mon2.turn + player_mon2.speed
		msg.post("gui", "update_turn", {target="player_mon2", current=player_mon2.turn, max=1000})
	end
	if player_mon3 ~= nil then
		player_mon3.turn = player_mon3.turn + player_mon3.speed
		msg.post("gui", "update_turn", {target="player_mon3", current=player_mon3.turn, max=1000})
	end
	if player_mon4 ~= nil then
		player_mon4.turn = player_mon4.turn + player_mon4.speed
		msg.post("gui", "update_turn", {target="player_mon4", current=player_mon4.turn, max=1000})
	end
	enemy_mon1.turn = enemy_mon1.turn + enemy_mon1.speed
	msg.post("gui", "update_turn", {target="enemy_mon1", current=enemy_mon1.turn, max=1000})
	
	enemy_mon2.turn = enemy_mon2.turn + enemy_mon2.speed
	msg.post("gui", "update_turn", {target="enemy_mon2", current=enemy_mon2.turn, max=1000})
	
	enemy_mon3.turn = enemy_mon3.turn + enemy_mon3.speed
	msg.post("gui", "update_turn", {target="enemy_mon3", current=enemy_mon3.turn, max=1000})
	
	enemy_mon4.turn = enemy_mon4.turn + enemy_mon4.speed
	msg.post("gui", "update_turn", {target="enemy_mon4", current=enemy_mon4.turn, max=1000})
	
	msg.post(".", "find_next_turn")
end


function load_player_mon_data()
	player_mon1 = game_state.pokemon[game_state.player_mon1]
	player_mon1.currenthp = player_mon1.hp
	player_mon1.turn = 0
	player_mon1.reference = "player_mon1"
	player_mon1.move1cd = 0
	player_mon1.move2cd = 0
	player_mon1.move3cd = 0
	player_mon1.move4cd = 0
	player_mon1.buffs_debuffs = {}
	msg.post("player_mon1#sprite", "play_animation", { id = hash(player_mon1.name.."_back_original") })
	combatants["player_mon1"] = player_mon1

	if game_state.player_mon2 ~= nil then
		player_mon2 = game_state.pokemon[game_state.player_mon2]
		player_mon2.currenthp = player_mon2.hp
		player_mon2.turn = 0
		player_mon2.reference = "player_mon2"
		player_mon2.move1cd = 0
		player_mon2.move2cd = 0
		player_mon2.move3cd = 0
		player_mon2.move4cd = 0
		player_mon2.buffs_debuffs = {}
		msg.post("player_mon2#sprite", "play_animation", { id = hash(player_mon2.name.."_back_original") })
		combatants["player_mon2"] = player_mon2
	else
		msg.post("player_mon2", "disable")
		msg.post("gui", "disable_mon", {mon = "player_mon2"})
	end

	if game_state.player_mon3 ~= nil then
		player_mon3 = game_state.pokemon[game_state.player_mon3]
		player_mon3.currenthp = player_mon3.hp
		player_mon3.turn = 0
		player_mon3.reference = "player_mon3"
		player_mon3.move1cd = 0
		player_mon3.move2cd = 0
		player_mon3.move3cd = 0
		player_mon3.move4cd = 0
		player_mon3.buffs_debuffs = {}
		msg.post("player_mon3#sprite", "play_animation", { id = hash(player_mon3.name.."_back_original") })
		combatants["player_mon3"] = player_mon3
	else
		msg.post("player_mon3", "disable")
		msg.post("gui", "disable_mon", {mon = "player_mon3"})
	end

	if game_state.player_mon4 ~= nil then
		player_mon4 = game_state.pokemon[game_state.player_mon4]
		player_mon4.currenthp = player_mon4.hp
		player_mon4.turn = 0
		player_mon4.reference = "player_mon4"
		player_mon4.move1cd = 0
		player_mon4.move2cd = 0
		player_mon4.move3cd = 0
		player_mon4.move4cd = 0
		player_mon4.buffs_debuffs = {}
		msg.post("player_mon4#sprite", "play_animation", { id = hash(player_mon4.name.."_back_original") })
		combatants["player_mon4"] = player_mon4
	else
		msg.post("player_mon4", "disable")
		msg.post("gui", "disable_mon", {mon = "player_mon4"})
	end
end

function load_enemy_data()
	--TODO: copy stats?
	enemy_mon1 = game_state.enemy_mon1
	enemy_mon1.currenthp = enemy_mon1.hp
	enemy_mon1.turn = 0
	enemy_mon1.reference = "enemy_mon1"
	enemy_mon1.move1cd = 0
	enemy_mon1.move2cd = 0
	enemy_mon1.move3cd = 0
	enemy_mon1.move4cd = 0
	enemy_mon1.buffs_debuffs = {}
	msg.post("enemy_mon1#sprite", "play_animation", { id = hash(enemy_mon1.name.."_front_original") })
	combatants["enemy_mon1"] = enemy_mon1

	enemy_mon2 = game_state.enemy_mon2
	enemy_mon2.currenthp = enemy_mon2.hp
	enemy_mon2.turn = 0
	enemy_mon2.reference = "enemy_mon1"
	enemy_mon2.move1cd = 0
	enemy_mon2.move2cd = 0
	enemy_mon2.move3cd = 0
	enemy_mon2.move4cd = 0
	enemy_mon2.buffs_debuffs = {}
	msg.post("enemy_mon2#sprite", "play_animation", { id = hash(enemy_mon2.name.."_front_original") })
	combatants["enemy_mon2"] = enemy_mon2

	enemy_mon3 = game_state.enemy_mon3
	enemy_mon3.currenthp = enemy_mon3.hp
	enemy_mon3.turn = 0
	enemy_mon3.reference = "enemy_mon3"
	enemy_mon3.move1cd = 0
	enemy_mon3.move2cd = 0
	enemy_mon3.move3cd = 0
	enemy_mon3.move4cd = 0
	enemy_mon3.buffs_debuffs = {}
	msg.post("enemy_mon3#sprite", "play_animation", { id = hash(enemy_mon3.name.."_front_original") })
	combatants["enemy_mon3"] = enemy_mon3

	enemy_mon4 = game_state.enemy_mon4
	enemy_mon4.currenthp = enemy_mon4.hp
	enemy_mon4.turn = 0
	enemy_mon4.reference = "enemy_mon4"
	enemy_mon4.move1cd = 0
	enemy_mon4.move2cd = 0
	enemy_mon4.move3cd = 0
	enemy_mon4.move4cd = 0
	enemy_mon4.buffs_debuffs = {}
	msg.post("enemy_mon4#sprite", "play_animation", { id = hash(enemy_mon4.name.."_front_original") })
	combatants["enemy_mon4"] = enemy_mon4
end

function display_targetting_icons()
	if(selected_move.targetting == 0) then --self
		local p = go.get_position(current_turn_mon.reference)
		p.y = p.y + 50
		local icon = factory.create("#target_icon_factory",p)
		table.insert(spawned_target_icons, icon)
	elseif(selected_move.targetting == 1) then --enemy
		for i=1,4 do
			local p = go.get_position("enemy_mon"..i)
			p.y = p.y + 50
			local icon = factory.create("#target_icon_factory",p)
			table.insert(spawned_target_icons, icon)
		end
	elseif(selected_move.targetting == 2) then --ally
		for i=1,4 do
			local p = go.get_position("player_mon"..i)
			p.y = p.y + 50
			local icon = factory.create("#target_icon_factory",p)
			table.insert(spawned_target_icons, icon)
		end
	end
end

function target_is_valid(target)
	if(selected_move.targetting == 0 and target == current_turn_mon.reference) then
		return true
	elseif(selected_move.targetting == 1 and string.match(target, "^enemy")) then
		return true
	elseif(selected_move.targetting == 2 and string.match(target, "^player")) then
		return true
	else
		return false
	end
end

function clear_gos(id_table)
	for i, v in ipairs(id_table) do
		go.delete(v)
		id_table[i] = nil
	end
end