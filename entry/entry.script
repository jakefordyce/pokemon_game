local MANIFEST_FILENAME = "liveupdate.game.dmanifest"
local LIVEUPDATE_URL = "https://raw.githubusercontent.com/jakefordyce/pokemon_game/live-update-setup/"
local ZIP_FILENAME = 'resources.zip'
local APP_SAVE_DIR = "pokemon"

function init(self)
	msg.post(".", "acquire_input_focus")
	msg.post("#", "attempt_download_resources")
end

function final(self)
end

function update(self, dt)
end

-- helper function to store headers from the http request (e.g. the ETag)
local function store_http_response_headers(name, data)
	local path = sys.get_save_file(APP_SAVE_DIR, name)
	sys.save(path, data)
end

local function load_http_response_headers(name)
	local path = sys.get_save_file(APP_SAVE_DIR, name)
	return sys.load(path)
end

-- returns headers that can potentially generate a 304
-- without redownloading the file again
local function get_http_request_headers(name)
	local data = load_http_response_headers(name)
	local headers = {}
	for k, v in pairs(data) do
		if string.lower(k) == 'etag' then
			headers['If-None-Match'] = v
		elseif string.lower(k) == 'last-modified' then
			headers['If-Modified-Since'] = v
		end
	end
	return headers
end

local function store_archive_cb(self, path, status)
	if status == true then
		print("Successfully stored live update archive!", path)
		sys.reboot()
	else
		print("Failed to store live update archive, ", path)
	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("proxy_loaded") then
		msg.post(sender, "init")
		msg.post(sender, "enable")
	elseif message_id == hash("attempt_download_resources") then
		print("application path: "..sys.get_application_path())
		print("save path: "..sys.get_save_file("Pokemon", "save_file"))

		-- by supplying the ETag, we don't have to redownload the file again
		-- if we already have downloaded it.
		local headers = get_http_request_headers(ZIP_FILENAME .. '.json')
		if not resource.is_using_liveupdate_data() then
			headers = {} -- live update data has been purged, and we need do a fresh download
		end

		local path = sys.get_save_file(APP_SAVE_DIR, ZIP_FILENAME)
		local options = {
			path = path,        -- a temporary file on disc. will be removed upon successful liveupdate storage
			ignore_cache = true -- we don't want to store a (potentially large) duplicate in our http cache
		}

		local url = LIVEUPDATE_URL .. ZIP_FILENAME
		print("Downloading", url)
		http.request(url, "GET", function(self, id, response)
			print("response status"..response.status)
			if response.status == 304 then
				print(string.format("%d: Archive zip file up-to-date", response.status))
			elseif response.status == 200 and response.error == nil then
				-- register the path to the live update system
				
				resource.store_archive(path, store_archive_cb)
				-- at this point, the "path" has been moved internally to a different location

				-- save the ETag for the next run
				store_http_response_headers(ZIP_FILENAME .. '.json', response.headers)
			else
				print("Error when downloading", url, "to", path, ":", response.status, response.error)
			end

			-- If we got a 200, we would call store_archive_cb() then reboot
			-- Second time, if we get here, it should be after a 304, and then
			-- we can load the missing resources from the liveupdate archive
			if resource.is_using_liveupdate_data() then
				msg.post("#main", "load")
			end
		end,
		headers, nil, options)
	end
end

function on_input(self, action_id, action)
end

function on_reload(self)
end
