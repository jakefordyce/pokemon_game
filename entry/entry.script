local MANIFEST_FILENAME = "liveupdate.game.dmanifest"
local LIVEUPDATE_URL = "https://raw.githubusercontent.com/jakefordyce/pokemon_game/live-update-setup/"
local ZIP_FILENAME = 'pokemon.zip'
local APP_SAVE_DIR = "pokemon"

function init(self)
	msg.post(".", "acquire_input_focus")
	self.resources_pending = 0
	msg.post("#", "attempt_download_manifest")
	--msg.post("#", "attempt_load_resources")
end

function final(self)
end

function update(self, dt)
end

-- helper function to store headers from the http request (e.g. the ETag)
local function store_http_response_headers(name, data)
	local path = sys.get_save_file(APP_SAVE_DIR, name)
	sys.save(path, data)
end

local function load_http_response_headers(name)
	local path = sys.get_save_file(APP_SAVE_DIR, name)
	return sys.load(path)
end

-- returns headers that can potentially generate a 304
-- without redownloading the file again
local function get_http_request_headers(name)
	local data = load_http_response_headers(name)
	local headers = {}
	for k, v in pairs(data) do
		if string.lower(k) == 'etag' then
			headers['If-None-Match'] = v
		elseif string.lower(k) == 'last-modified' then
			headers['If-Modified-Since'] = v
		end
	end
	return headers
end

local function store_archive_cb(self, path, status)
	if status == true then
		print("Successfully stored live update archive!", path)
		sys.reboot()
	else
		print("Failed to store live update archive, ", path)
		-- remove the path
	end
end

local function store_manifest_cb(self, status)
	if status == resource.LIVEUPDATE_OK then
		print("Successfully stored manifest!")
	else
		print("Failed to store manifest, status: ", status)
	end
end

-- This function is called whenever we have tried to store a downloaded resource
-- necessary for our collection proxy to load.
local function resource_store_response(self, hexdigest, status)
	if status == true then
		-- Successfully loaded resource
		print("Resource data stored: " .. hexdigest)

		-- One less resource to go...
		self.resources_pending = self.resources_pending - 1

		-- That was all of them, time to load the proxied collection.
		if self.resources_pending == 0 then
			msg.post("#main", "load") -- <8>
		end
	else
		-- ERROR! Failed to store the data!
		print("Failed to store resource data: " .. hexdigest)
	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("attempt_load_resources") then
		local missing_resources = collectionproxy.missing_resources("#main") -- <2>

		print("missing resources: "..#missing_resources)
		-- initiate a download request for each of the missing resources that has not yet been tried.
		for _,resource_hash in ipairs(missing_resources) do
			msg.post("#", "attempt_download", { resource_hash = resource_hash})
		end

		self.resources_pending = #missing_resources -- <3>

		-- if we're running from editor all resources are there from the start.
		if self.resources_pending == 0 then
			msg.post("#main", "load")
		end
	elseif message_id == hash("attempt_download") then
		local manifest = resource.get_current_manifest()
		local base_url = sys.get_save_file(APP_SAVE_DIR, ZIP_FILENAME)
		local file_to_read = message.resource_hash
		local file = io.open(file_to_read, "rb")
		local content = file:read("*a")
		file:close()
		
		if content ~= nil then
			print("storing " .. message.resource_hash)
			resource.store_resource(manifest, content, message.resource_hash, resource_store_response)
		else
			-- ERROR! Failed to download resource!
			print("Failed to download resource: " .. message.resource_hash)
		end
		
	elseif message_id == hash("proxy_loaded") then
		msg.post(sender, "init")
		msg.post(sender, "enable")
	elseif message_id == hash("attempt_download_manifest") then
		print("application path: "..sys.get_application_path())
		print("save path: "..sys.get_save_file("Pokemon", "save_file"))

		-- something to try if I come back to Defold.
		--https://defold.com/ref/stable/resource/#resource.store_archive:path-callback

		-- by supplying the ETag, we don't have to redownload the file again
		-- if we already have downloaded it.
		local headers = get_http_request_headers(ZIP_FILENAME .. '.json')
		--if not resource.is_using_liveupdate_data() then
			headers = {} -- live update data has been purged, and we need do a fresh download
		--end

		local path = sys.get_save_file(APP_SAVE_DIR, ZIP_FILENAME)
		local options = {
			path = path,        -- a temporary file on disc. will be removed upon successful liveupdate storage
			ignore_cache = true -- we don't want to store a (potentially large) duplicate in our http cache
		}

		local url = LIVEUPDATE_URL .. ZIP_FILENAME
		print("Downloading", url)
		http.request(url, "GET", function(self, id, response)
			print("response status"..response.status)
			if response.status == 304 then
				print(string.format("%d: Archive zip file up-to-date", response.status))
			elseif response.status == 200 and response.error == nil then
				-- register the path to the live update system
				
				resource.store_archive(path, store_archive_cb)
				-- at this point, the "path" has been moved internally to a different location

				-- save the ETag for the next run
				store_http_response_headers(ZIP_FILENAME .. '.json', response.headers)
			else
				print("Error when downloading", url, "to", path, ":", response.status, response.error)
			end

			-- If we got a 200, we would call store_archive_cb() then reboot
			-- Second time, if we get here, it should be after a 304, and then
			-- we can load the missing resources from the liveupdate archive
			if resource.is_using_liveupdate_data() then
				msg.post("#main", "load")
				--msg.post(self.proxy, "load")
			end
		end,
		headers, nil, options)

		--msg.post("#", "attempt_load_resources")
		--[[
		local file = io.open(file_to_read, "rb")
		local content
		if file ~= nil then
			content = file:read("*a")
			file:close()
		end
		if content ~= nil then
			-- We read the manifest. Compare to current manifest

			local current_manifest_url = sys.get_application_path().."/game.dmanifest"
			print("current manifest url: "..current_manifest_url)
			local current_manifest_file = io.open(current_manifest_url, "rb")
			local current_content
			if (current_manifest_file ~= nil) then
				current_content = current_manifest_file:read("*a")
				current_manifest_file:close()
			end
			

			if(current_content ~= nil and content == current_content) then
				print("content the same")
			elseif(current_content ~= nil and content ~= current_content) then
				print("New manifest found. Saving new manifest and rebooting app.")
				current_manifest_file = io.open(current_manifest_url, "w+b")
				current_manifest_file:write(content)
				current_manifest_file:flush()
				os.remove(sys.get_save_file("60cc2a923a97e8eb7a2d00659c1f05a72d47db56", "liveupdate.arcd"))
				os.remove(sys.get_save_file("60cc2a923a97e8eb7a2d00659c1f05a72d47db56", "liveupdate.arci"))
				os.remove(sys.get_save_file("60cc2a923a97e8eb7a2d00659c1f05a72d47db56", "liveupdate.arci.tmp"))
				sys.reboot()
				return true
			end
			
			--print("verifying and storing manifest " .. MANIFEST_FILENAME)
			--resource.store_manifest(content, store_manifest_cb)
		else
			-- ERROR! Failed to download manifest!
			print("Failed to download manifest: " .. MANIFEST_FILENAME)
		end
		msg.post("#", "attempt_load_resources")
		--]]
	end
end

function on_input(self, action_id, action)
end

function on_reload(self)
end
